
lib: 1
lic: 1

CoppeliaSim Edu V4.0.0. (rev. 4)
Using the default Lua library.
Loaded the video compression library.
Add-on script 'simAddOnScript-addOnScriptDemo.lua' was loaded.
Add-on script 'simAddOnScript-b0RemoteApiServer.lua' was loaded.
Add-on script 'simAddOnScript_PyRep.lua' was loaded.
If CoppeliaSim crashes now, try to install libgl1-mesa-dev on your system:
>sudo apt install libgl1-mesa-dev
OpenGL: Parallels and ATI Technologies Inc., Renderer: Parallels using AMD Radeon Pro 560X OpenGL Engine, Version: 2.1 ATI-3.5.5
...did not crash.
Simulator launched.
Plugin 'Geometric': loading...
Plugin 'Geometric': load succeeded.
Plugin 'Assimp': loading...
Plugin 'Assimp': warning: replaced variable 'simAssimp'
Plugin 'Assimp': load succeeded.
Plugin 'BlueZero': loading...
Plugin 'BlueZero': warning: replaced variable 'simB0'
Plugin 'BlueZero': load succeeded.
Plugin 'BubbleRob': loading...
Plugin 'BubbleRob': load succeeded.
Plugin 'Bwf': loading...
Plugin 'Bwf': load succeeded.
Plugin 'CodeEditor': loading...
Plugin 'CodeEditor': load succeeded.
Plugin 'Collada': loading...
Plugin 'Collada': load succeeded.
Plugin 'ConvexDecompose': loading...
Plugin 'ConvexDecompose': load succeeded.
Plugin 'CustomUI': loading...
Plugin 'CustomUI': warning: replaced variable 'simUI'
Plugin 'CustomUI': warning: replaced function 'simUI.insertTableRow@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.removeTableRow@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.insertTableColumn@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.removeTableColumn@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.setScene3DNodeParam@CustomUI'
Plugin 'CustomUI': load succeeded.
Plugin 'DynamicsBullet-2-78': loading...
Plugin 'DynamicsBullet-2-78': load succeeded.
Plugin 'DynamicsBullet-2-83': loading...
Plugin 'DynamicsBullet-2-83': load succeeded.
Plugin 'DynamicsNewton': loading...
Plugin 'DynamicsNewton': load succeeded.
Plugin 'DynamicsOde': loading...
Plugin 'DynamicsOde': load succeeded.
Plugin 'DynamicsVortex': loading...
Plugin 'DynamicsVortex': load succeeded.
Plugin 'ExternalRenderer': loading...
Plugin 'ExternalRenderer': load succeeded.
Plugin 'ICP': loading...
Plugin 'ICP': warning: replaced variable 'simICP'
Plugin 'ICP': load succeeded.
Plugin 'Image': loading...
Plugin 'Image': warning: replaced variable 'simIM'
Plugin 'Image': load succeeded.
Plugin 'K3': loading...
Plugin 'K3': load succeeded.
Plugin 'Lic': loading...
Plugin 'Lic': load succeeded.
Plugin 'LuaCommander': loading...
Plugin 'LuaCommander': warning: replaced variable 'simLuaCmd'
Plugin 'LuaCommander': load succeeded.
Plugin 'LuaRemoteApiClient': loading...
Plugin 'LuaRemoteApiClient': load succeeded.
Plugin 'Mtb': loading...
Plugin 'Mtb': load succeeded.
Plugin 'OMPL': loading...
Plugin 'OMPL': warning: replaced variable 'simOMPL'
Plugin 'OMPL': load succeeded.
Plugin 'OpenGL3Renderer': loading...
Plugin 'OpenGL3Renderer': load succeeded.
Plugin 'OpenMesh': loading...
Plugin 'OpenMesh': load succeeded.
Plugin 'Qhull': loading...
Plugin 'Qhull': load succeeded.
Plugin 'RRS1': loading...
Plugin 'RRS1': load succeeded.
Plugin 'ReflexxesTypeII': loading...
Plugin 'ReflexxesTypeII': load succeeded.
Plugin 'RemoteApi': loading...
Starting a remote API server on port 19997
Plugin 'RemoteApi': load succeeded.
Plugin 'SDF': loading...
Plugin 'SDF': warning: replaced variable 'simSDF'
Plugin 'SDF': load succeeded.
Plugin 'SurfaceReconstruction': loading...
Plugin 'SurfaceReconstruction': warning: replaced variable 'simSurfRec'
Plugin 'SurfaceReconstruction': load succeeded.
Plugin 'Urdf': loading...
Plugin 'Urdf': load succeeded.
Plugin 'Vision': loading...
Plugin 'Vision': load succeeded.
Using the 'Geometric' plugin.
Initializing the Bullet physics engine in plugin 'DynamicsBullet_2_83'...
Engine version: 2.83.7
Plugin version: 11
Initialization successful.
This renderer requires atleast OpenGL 3.2. The version available is: 2.1 ATI-3.5.5
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoords = aTexCoords;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:108: '(' : syntax error: Array size must appear after variable name

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

struct Material {
    vec4 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct DirLight {
    vec3 position; // specifically for shadows
    vec3 direction;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float farPlane;
    float bias;
    float normalBias;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

uniform sampler2D texture0;
uniform int textureApplyMode;

uniform vec3 sceneAmbient;
uniform vec3 viewPos;

// Some graphics cards appear not to support arrays. One way around this is to explicitly roll out the array.
#define MAX_LIGHTS 5
uniform DirLight dirLight0;
uniform DirLight dirLight1;
uniform DirLight dirLight2;
uniform DirLight dirLight3;
uniform DirLight dirLight4;

uniform PointLight pointLight0;
uniform PointLight pointLight1;
uniform PointLight pointLight2;
uniform PointLight pointLight3;
uniform PointLight pointLight4;

uniform SpotLight spotLight0;
uniform SpotLight spotLight1;
uniform SpotLight spotLight2;
uniform SpotLight spotLight3;
uniform SpotLight spotLight4;

// For some reason, we are not allowed to store samplerCube in structs or arrays
// So allow a max of 5
uniform samplerCube depthCubeMap0;
uniform samplerCube depthCubeMap1;
uniform samplerCube depthCubeMap2;
uniform samplerCube depthCubeMap3;
uniform samplerCube depthCubeMap4;

uniform int dirLightLen;
uniform int pointLightLen;
uniform int spotLightLen;

uniform Material material;

// array of offset direction for sampling in pointlight shadows
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1),
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

// function prototypes
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias);
float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias);

void main()
{
    // Lighting properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // Give it some intial ambient light
    vec4 ambient = texture(texture0, TexCoords);

    // textureApplyMode 1 (GL_DECAL) gets applied later.
    if (textureApplyMode == 2)  // ADD
        ambient = (ambient + material.ambient, 1.0) * vec4(sceneAmbient, 1.0);
    else if (textureApplyMode == 1)
        ambient = material.ambient;
    else if (textureApplyMode != 1)
        // In this case, we either have no texture, or we want to use GL_BLEND.
        ambient *= material.ambient * vec4(sceneAmbient, 1.0);

    vec3 result = vec3(0.0);
    // phase 1: directional lighting
    for(int i = 0; i < dirLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcDirLight(dirLight0, norm, viewDir);
            shadow = ShadowCalculation(dirLight0.lightSpaceMatrix, dirLight0.position, dirLight0.shadowMap, dirLight0.bias, dirLight0.normalBias);
        } else if (i == 1){
            lresult = CalcDirLight(dirLight1, norm, viewDir);
            shadow = ShadowCalculation(dirLight1.lightSpaceMatrix, dirLight1.position, dirLight1.shadowMap, dirLight1.bias, dirLight1.normalBias);
        } else if (i == 2){
            lresult = CalcDirLight(dirLight2, norm, viewDir);
            shadow = ShadowCalculation(dirLight2.lightSpaceMatrix, dirLight2.position, dirLight2.shadowMap, dirLight2.bias, dirLight2.normalBias);
        } else if (i == 3){
            lresult = CalcDirLight(dirLight3, norm, viewDir);
            shadow = ShadowCalculation(dirLight3.lightSpaceMatrix, dirLight3.position, dirLight3.shadowMap, dirLight3.bias, dirLight3.normalBias);
        } else if (i == 4){
            lresult = CalcDirLight(dirLight4, norm, viewDir);
            shadow = ShadowCalculation(dirLight4.lightSpaceMatrix, dirLight4.position, dirLight4.shadowMap, dirLight4.bias, dirLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 2: point lights
    for(int i = 0; i < pointLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;

        if (i == 0){
            lresult = CalcPointLight(pointLight0, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight0.position, depthCubeMap0, pointLight0.farPlane, pointLight0.bias, pointLight0.normalBias);
        }else if (i == 1){
            lresult = CalcPointLight(pointLight1, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight1.position, depthCubeMap1, pointLight1.farPlane, pointLight1.bias, pointLight1.normalBias);
        }else if (i == 2){
            lresult = CalcPointLight(pointLight2, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight2.position, depthCubeMap2, pointLight2.farPlane, pointLight2.bias, pointLight2.normalBias);
        }else if (i == 3){
            lresult = CalcPointLight(pointLight3, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight3.position, depthCubeMap3, pointLight3.farPlane, pointLight3.bias, pointLight3.normalBias);
        }else if (i == 4){
            lresult = CalcPointLight(pointLight4, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight4.position, depthCubeMap4, pointLight4.farPlane, pointLight4.bias, pointLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 3: spot light
    for(int i = 0; i < spotLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcSpotLight(spotLight0, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight0.lightSpaceMatrix, spotLight0.position, spotLight0.shadowMap, spotLight0.bias, spotLight0.normalBias);
        } else if (i == 1){
            lresult = CalcSpotLight(spotLight1, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight1.lightSpaceMatrix, spotLight1.position, spotLight1.shadowMap, spotLight1.bias, spotLight1.normalBias);
        } else if (i == 2){
            lresult = CalcSpotLight(spotLight2, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight2.lightSpaceMatrix, spotLight2.position, spotLight2.shadowMap, spotLight2.bias, spotLight2.normalBias);
        } else if (i == 3){
            lresult = CalcSpotLight(spotLight3, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight3.lightSpaceMatrix, spotLight3.position, spotLight3.shadowMap, spotLight3.bias, spotLight3.normalBias);
        } else if (i == 4){
            lresult = CalcSpotLight(spotLight4, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight4.lightSpaceMatrix, spotLight4.position, spotLight4.shadowMap, spotLight4.bias, spotLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }

    FragColor = ambient + vec4(result, 0.0);
    if (textureApplyMode == 1){
        // textureApplyMode == 1 is DECAL
        vec4 coltex = texture(texture0, TexCoords.st);
        vec3 col = FragColor.rgb * (1.0-coltex.a) + coltex.rgb * coltex.a;
        FragColor = vec4(col, FragColor.a);
    }
}

// calculates the color when using a directional light.
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading (Phong)
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    // specular shading (Blinn-Phong)
    // vec3 halfwayDir = normalize(lightDir + viewDir);
    // float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);

    // combine results
    vec3 diffuse = light.diffuse * (diff * (vec3(texture(texture0, TexCoords)) * material.diffuse));
    vec3 specular = light.specular * (spec * (vec3(texture(texture0, TexCoords)) * material.specular));
    return (diffuse + specular);
}

// calculates the color when using a point light.
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // combine results
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation;
    specular *= attenuation;
    return (diffuse + specular);
}

// calculates the color when using a spot light.
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);

    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results

    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;

    return (diffuse + specular);
}

float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias)
{
    vec4 fragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0);

    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    // check whether current frag pos is in shadow
    // PCF
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias)
{

    // get vector between fragment position and light position
    vec3 fragToLight = FragPos - lightPos;
    float currentDepth = length(fragToLight);

    float shadow = 0.0;

    // Bias calc
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    int samples = 20;
    float viewDistance = length(viewPos - FragPos);
    float diskRadius = (1.0 + (viewDistance / farPlane)) / 500.0;

    for(int i = 0; i < samples; i++)
    {
        float closestDepth = texture(cubeMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= farPlane;   // undo mapping [0;1]
        if((currentDepth - bias) > closestDepth){
            shadow += 1.0;
        }
    }
    shadow /= float(samples);
    return shadow;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:108: '(' : syntax error: Array size must appear after variable name\n"
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

uniform mat4 lightSpaceMatrix;
uniform mat4 model;

void main()
{
    gl_Position = lightSpaceMatrix * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

void main(void)
{
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\n"
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;

uniform mat4 model;

out vec3 FragPos;

uniform mat4 lightSpaceMatrix;

void main()
{
    gl_Position = lightSpaceMatrix * model * vec4(aPos, 1.0);
    FragPos = vec3(model * vec4(aPos, 1.0));
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1
in vec3 FragPos;

uniform vec3 lightPos;
uniform float far_plane;

void main()
{
    float lightDistance = length(FragPos - lightPos);

    // map to [0;1] range by dividing by far_plane
    lightDistance = lightDistance / far_plane;

    gl_FragDepth = lightDistance;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\n"
This renderer requires atleast OpenGL 3.2. The version available is: 2.1 ATI-3.5.5
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoords = aTexCoords;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:108: '(' : syntax error: Array size must appear after variable name

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

struct Material {
    vec4 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct DirLight {
    vec3 position; // specifically for shadows
    vec3 direction;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float farPlane;
    float bias;
    float normalBias;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

uniform sampler2D texture0;
uniform int textureApplyMode;

uniform vec3 sceneAmbient;
uniform vec3 viewPos;

// Some graphics cards appear not to support arrays. One way around this is to explicitly roll out the array.
#define MAX_LIGHTS 5
uniform DirLight dirLight0;
uniform DirLight dirLight1;
uniform DirLight dirLight2;
uniform DirLight dirLight3;
uniform DirLight dirLight4;

uniform PointLight pointLight0;
uniform PointLight pointLight1;
uniform PointLight pointLight2;
uniform PointLight pointLight3;
uniform PointLight pointLight4;

uniform SpotLight spotLight0;
uniform SpotLight spotLight1;
uniform SpotLight spotLight2;
uniform SpotLight spotLight3;
uniform SpotLight spotLight4;

// For some reason, we are not allowed to store samplerCube in structs or arrays
// So allow a max of 5
uniform samplerCube depthCubeMap0;
uniform samplerCube depthCubeMap1;
uniform samplerCube depthCubeMap2;
uniform samplerCube depthCubeMap3;
uniform samplerCube depthCubeMap4;

uniform int dirLightLen;
uniform int pointLightLen;
uniform int spotLightLen;

uniform Material material;

// array of offset direction for sampling in pointlight shadows
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1),
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

// function prototypes
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias);
float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias);

void main()
{
    // Lighting properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // Give it some intial ambient light
    vec4 ambient = texture(texture0, TexCoords);

    // textureApplyMode 1 (GL_DECAL) gets applied later.
    if (textureApplyMode == 2)  // ADD
        ambient = (ambient + material.ambient, 1.0) * vec4(sceneAmbient, 1.0);
    else if (textureApplyMode == 1)
        ambient = material.ambient;
    else if (textureApplyMode != 1)
        // In this case, we either have no texture, or we want to use GL_BLEND.
        ambient *= material.ambient * vec4(sceneAmbient, 1.0);

    vec3 result = vec3(0.0);
    // phase 1: directional lighting
    for(int i = 0; i < dirLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcDirLight(dirLight0, norm, viewDir);
            shadow = ShadowCalculation(dirLight0.lightSpaceMatrix, dirLight0.position, dirLight0.shadowMap, dirLight0.bias, dirLight0.normalBias);
        } else if (i == 1){
            lresult = CalcDirLight(dirLight1, norm, viewDir);
            shadow = ShadowCalculation(dirLight1.lightSpaceMatrix, dirLight1.position, dirLight1.shadowMap, dirLight1.bias, dirLight1.normalBias);
        } else if (i == 2){
            lresult = CalcDirLight(dirLight2, norm, viewDir);
            shadow = ShadowCalculation(dirLight2.lightSpaceMatrix, dirLight2.position, dirLight2.shadowMap, dirLight2.bias, dirLight2.normalBias);
        } else if (i == 3){
            lresult = CalcDirLight(dirLight3, norm, viewDir);
            shadow = ShadowCalculation(dirLight3.lightSpaceMatrix, dirLight3.position, dirLight3.shadowMap, dirLight3.bias, dirLight3.normalBias);
        } else if (i == 4){
            lresult = CalcDirLight(dirLight4, norm, viewDir);
            shadow = ShadowCalculation(dirLight4.lightSpaceMatrix, dirLight4.position, dirLight4.shadowMap, dirLight4.bias, dirLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 2: point lights
    for(int i = 0; i < pointLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;

        if (i == 0){
            lresult = CalcPointLight(pointLight0, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight0.position, depthCubeMap0, pointLight0.farPlane, pointLight0.bias, pointLight0.normalBias);
        }else if (i == 1){
            lresult = CalcPointLight(pointLight1, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight1.position, depthCubeMap1, pointLight1.farPlane, pointLight1.bias, pointLight1.normalBias);
        }else if (i == 2){
            lresult = CalcPointLight(pointLight2, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight2.position, depthCubeMap2, pointLight2.farPlane, pointLight2.bias, pointLight2.normalBias);
        }else if (i == 3){
            lresult = CalcPointLight(pointLight3, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight3.position, depthCubeMap3, pointLight3.farPlane, pointLight3.bias, pointLight3.normalBias);
        }else if (i == 4){
            lresult = CalcPointLight(pointLight4, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight4.position, depthCubeMap4, pointLight4.farPlane, pointLight4.bias, pointLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 3: spot light
    for(int i = 0; i < spotLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcSpotLight(spotLight0, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight0.lightSpaceMatrix, spotLight0.position, spotLight0.shadowMap, spotLight0.bias, spotLight0.normalBias);
        } else if (i == 1){
            lresult = CalcSpotLight(spotLight1, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight1.lightSpaceMatrix, spotLight1.position, spotLight1.shadowMap, spotLight1.bias, spotLight1.normalBias);
        } else if (i == 2){
            lresult = CalcSpotLight(spotLight2, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight2.lightSpaceMatrix, spotLight2.position, spotLight2.shadowMap, spotLight2.bias, spotLight2.normalBias);
        } else if (i == 3){
            lresult = CalcSpotLight(spotLight3, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight3.lightSpaceMatrix, spotLight3.position, spotLight3.shadowMap, spotLight3.bias, spotLight3.normalBias);
        } else if (i == 4){
            lresult = CalcSpotLight(spotLight4, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight4.lightSpaceMatrix, spotLight4.position, spotLight4.shadowMap, spotLight4.bias, spotLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }

    FragColor = ambient + vec4(result, 0.0);
    if (textureApplyMode == 1){
        // textureApplyMode == 1 is DECAL
        vec4 coltex = texture(texture0, TexCoords.st);
        vec3 col = FragColor.rgb * (1.0-coltex.a) + coltex.rgb * coltex.a;
        FragColor = vec4(col, FragColor.a);
    }
}

// calculates the color when using a directional light.
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading (Phong)
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    // specular shading (Blinn-Phong)
    // vec3 halfwayDir = normalize(lightDir + viewDir);
    // float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);

    // combine results
    vec3 diffuse = light.diffuse * (diff * (vec3(texture(texture0, TexCoords)) * material.diffuse));
    vec3 specular = light.specular * (spec * (vec3(texture(texture0, TexCoords)) * material.specular));
    return (diffuse + specular);
}

// calculates the color when using a point light.
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // combine results
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation;
    specular *= attenuation;
    return (diffuse + specular);
}

// calculates the color when using a spot light.
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);

    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results

    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;

    return (diffuse + specular);
}

float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias)
{
    vec4 fragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0);

    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    // check whether current frag pos is in shadow
    // PCF
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias)
{

    // get vector between fragment position and light position
    vec3 fragToLight = FragPos - lightPos;
    float currentDepth = length(fragToLight);

    float shadow = 0.0;

    // Bias calc
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    int samples = 20;
    float viewDistance = length(viewPos - FragPos);
    float diskRadius = (1.0 + (viewDistance / farPlane)) / 500.0;

    for(int i = 0; i < samples; i++)
    {
        float closestDepth = texture(cubeMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= farPlane;   // undo mapping [0;1]
        if((currentDepth - bias) > closestDepth){
            shadow += 1.0;
        }
    }
    shadow /= float(samples);
    return shadow;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:108: '(' : syntax error: Array size must appear after variable name\n"
This renderer requires atleast OpenGL 3.2. The version available is: 2.1 ATI-3.5.5
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoords = aTexCoords;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:108: '(' : syntax error: Array size must appear after variable name

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

struct Material {
    vec4 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct DirLight {
    vec3 position; // specifically for shadows
    vec3 direction;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float farPlane;
    float bias;
    float normalBias;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

uniform sampler2D texture0;
uniform int textureApplyMode;

uniform vec3 sceneAmbient;
uniform vec3 viewPos;

// Some graphics cards appear not to support arrays. One way around this is to explicitly roll out the array.
#define MAX_LIGHTS 5
uniform DirLight dirLight0;
uniform DirLight dirLight1;
uniform DirLight dirLight2;
uniform DirLight dirLight3;
uniform DirLight dirLight4;

uniform PointLight pointLight0;
uniform PointLight pointLight1;
uniform PointLight pointLight2;
uniform PointLight pointLight3;
uniform PointLight pointLight4;

uniform SpotLight spotLight0;
uniform SpotLight spotLight1;
uniform SpotLight spotLight2;
uniform SpotLight spotLight3;
uniform SpotLight spotLight4;

// For some reason, we are not allowed to store samplerCube in structs or arrays
// So allow a max of 5
uniform samplerCube depthCubeMap0;
uniform samplerCube depthCubeMap1;
uniform samplerCube depthCubeMap2;
uniform samplerCube depthCubeMap3;
uniform samplerCube depthCubeMap4;

uniform int dirLightLen;
uniform int pointLightLen;
uniform int spotLightLen;

uniform Material material;

// array of offset direction for sampling in pointlight shadows
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1),
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

// function prototypes
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias);
float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias);

void main()
{
    // Lighting properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // Give it some intial ambient light
    vec4 ambient = texture(texture0, TexCoords);

    // textureApplyMode 1 (GL_DECAL) gets applied later.
    if (textureApplyMode == 2)  // ADD
        ambient = (ambient + material.ambient, 1.0) * vec4(sceneAmbient, 1.0);
    else if (textureApplyMode == 1)
        ambient = material.ambient;
    else if (textureApplyMode != 1)
        // In this case, we either have no texture, or we want to use GL_BLEND.
        ambient *= material.ambient * vec4(sceneAmbient, 1.0);

    vec3 result = vec3(0.0);
    // phase 1: directional lighting
    for(int i = 0; i < dirLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcDirLight(dirLight0, norm, viewDir);
            shadow = ShadowCalculation(dirLight0.lightSpaceMatrix, dirLight0.position, dirLight0.shadowMap, dirLight0.bias, dirLight0.normalBias);
        } else if (i == 1){
            lresult = CalcDirLight(dirLight1, norm, viewDir);
            shadow = ShadowCalculation(dirLight1.lightSpaceMatrix, dirLight1.position, dirLight1.shadowMap, dirLight1.bias, dirLight1.normalBias);
        } else if (i == 2){
            lresult = CalcDirLight(dirLight2, norm, viewDir);
            shadow = ShadowCalculation(dirLight2.lightSpaceMatrix, dirLight2.position, dirLight2.shadowMap, dirLight2.bias, dirLight2.normalBias);
        } else if (i == 3){
            lresult = CalcDirLight(dirLight3, norm, viewDir);
            shadow = ShadowCalculation(dirLight3.lightSpaceMatrix, dirLight3.position, dirLight3.shadowMap, dirLight3.bias, dirLight3.normalBias);
        } else if (i == 4){
            lresult = CalcDirLight(dirLight4, norm, viewDir);
            shadow = ShadowCalculation(dirLight4.lightSpaceMatrix, dirLight4.position, dirLight4.shadowMap, dirLight4.bias, dirLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 2: point lights
    for(int i = 0; i < pointLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;

        if (i == 0){
            lresult = CalcPointLight(pointLight0, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight0.position, depthCubeMap0, pointLight0.farPlane, pointLight0.bias, pointLight0.normalBias);
        }else if (i == 1){
            lresult = CalcPointLight(pointLight1, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight1.position, depthCubeMap1, pointLight1.farPlane, pointLight1.bias, pointLight1.normalBias);
        }else if (i == 2){
            lresult = CalcPointLight(pointLight2, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight2.position, depthCubeMap2, pointLight2.farPlane, pointLight2.bias, pointLight2.normalBias);
        }else if (i == 3){
            lresult = CalcPointLight(pointLight3, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight3.position, depthCubeMap3, pointLight3.farPlane, pointLight3.bias, pointLight3.normalBias);
        }else if (i == 4){
            lresult = CalcPointLight(pointLight4, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight4.position, depthCubeMap4, pointLight4.farPlane, pointLight4.bias, pointLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 3: spot light
    for(int i = 0; i < spotLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcSpotLight(spotLight0, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight0.lightSpaceMatrix, spotLight0.position, spotLight0.shadowMap, spotLight0.bias, spotLight0.normalBias);
        } else if (i == 1){
            lresult = CalcSpotLight(spotLight1, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight1.lightSpaceMatrix, spotLight1.position, spotLight1.shadowMap, spotLight1.bias, spotLight1.normalBias);
        } else if (i == 2){
            lresult = CalcSpotLight(spotLight2, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight2.lightSpaceMatrix, spotLight2.position, spotLight2.shadowMap, spotLight2.bias, spotLight2.normalBias);
        } else if (i == 3){
            lresult = CalcSpotLight(spotLight3, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight3.lightSpaceMatrix, spotLight3.position, spotLight3.shadowMap, spotLight3.bias, spotLight3.normalBias);
        } else if (i == 4){
            lresult = CalcSpotLight(spotLight4, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight4.lightSpaceMatrix, spotLight4.position, spotLight4.shadowMap, spotLight4.bias, spotLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }

    FragColor = ambient + vec4(result, 0.0);
    if (textureApplyMode == 1){
        // textureApplyMode == 1 is DECAL
        vec4 coltex = texture(texture0, TexCoords.st);
        vec3 col = FragColor.rgb * (1.0-coltex.a) + coltex.rgb * coltex.a;
        FragColor = vec4(col, FragColor.a);
    }
}

// calculates the color when using a directional light.
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading (Phong)
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    // specular shading (Blinn-Phong)
    // vec3 halfwayDir = normalize(lightDir + viewDir);
    // float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);

    // combine results
    vec3 diffuse = light.diffuse * (diff * (vec3(texture(texture0, TexCoords)) * material.diffuse));
    vec3 specular = light.specular * (spec * (vec3(texture(texture0, TexCoords)) * material.specular));
    return (diffuse + specular);
}

// calculates the color when using a point light.
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // combine results
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation;
    specular *= attenuation;
    return (diffuse + specular);
}

// calculates the color when using a spot light.
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);

    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results

    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;

    return (diffuse + specular);
}

float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias)
{
    vec4 fragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0);

    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    // check whether current frag pos is in shadow
    // PCF
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias)
{

    // get vector between fragment position and light position
    vec3 fragToLight = FragPos - lightPos;
    float currentDepth = length(fragToLight);

    float shadow = 0.0;

    // Bias calc
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    int samples = 20;
    float viewDistance = length(viewPos - FragPos);
    float diskRadius = (1.0 + (viewDistance / farPlane)) / 500.0;

    for(int i = 0; i < samples; i++)
    {
        float closestDepth = texture(cubeMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= farPlane;   // undo mapping [0;1]
        if((currentDepth - bias) > closestDepth){
            shadow += 1.0;
        }
    }
    shadow /= float(samples);
    return shadow;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:108: '(' : syntax error: Array size must appear after variable name\n"
/home/zhenwang/code/git/robotics/PyRep/pyrep/pyrep.py:209: UserWarning: Could not change simulation timestep. You may need to change it to "custom dt" using simulation settings dialog.
  warnings.warn('Could not change simulation timestep. You may need '
/home/zhenwang/software/anaconda3/envs/robotics/lib/python3.7/site-packages/gym/logger.py:30: UserWarning: [33mWARN: Box bound precision lowered by casting to float32[0m
  warnings.warn(colorize('%s: %s'%('WARN', msg % args), 'yellow'))
Actor(
  (backbones): Backbones(
    (hidden): ModuleList(
      (0): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (1): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (2): Sequential(
        (0): Linear(in_features=3, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
    )
    (cnn_tail): ModuleList()
  )
  (fc_body): Sequential(
    (0): Linear(in_features=96, out_features=128, bias=True)
    (1): LeakyReLU(negative_slope=0.01, inplace=True)
    (2): Linear(in_features=128, out_features=128, bias=True)
    (3): LeakyReLU(negative_slope=0.01, inplace=True)
    (4): Linear(in_features=128, out_features=8, bias=True)
    (5): Tanh()
  )
)
Critic(
  (backbones): Backbones(
    (hidden): ModuleList(
      (0): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (1): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (2): Sequential(
        (0): Linear(in_features=3, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
    )
    (cnn_tail): ModuleList()
  )
  (fc_body): Sequential(
    (0): Linear(in_features=96, out_features=128, bias=True)
    (1): LeakyReLU(negative_slope=0.01, inplace=True)
  )
  (critic_body): Sequential(
    (0): Linear(in_features=136, out_features=64, bias=True)
    (1): LeakyReLU(negative_slope=0.01, inplace=True)
    (2): Linear(in_features=64, out_features=1, bias=True)
  )
)
Traceback (most recent call last):
  File "single_task_rl_ddpg.py", line 109, in <module>
    agent.load()
  File "/home/zhenwang/code/git/robotics/RLBench/examples/ddpg/ddpg_agent.py", line 209, in load
    self.actor_local.load_state_dict(torch.load("checkpoints/checkpoint_actor.pth"))
  File "/home/zhenwang/software/anaconda3/envs/robotics/lib/python3.7/site-packages/torch/serialization.py", line 419, in load
    f = open(f, 'rb')
FileNotFoundError: [Errno 2] No such file or directory: 'checkpoints/checkpoint_actor.pth'


Error: signal 11:

/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libcoppeliaSim.so.1(_Z11_segHandleri+0x2b)[0x7fc3a91ee0bb]
/lib/x86_64-linux-gnu/libc.so.6(+0x3ef20)[0x7fc3b839cf20]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Core.so.5(_ZN6QMutex4lockEv+0x15)[0x7fc3a705e375]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Gui.so.5(+0x387b0e)[0x7fc3a7cf1b0e]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Gui.so.5(+0x37f3cf)[0x7fc3a7ce93cf]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Gui.so.5(_ZN18QRasterPaintEngine11updateBrushERK6QBrush+0x87)[0x7fc3a7cec837]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Gui.so.5(_ZN18QRasterPaintEngine8fillRectERK6QRectFRK6QBrush+0x2a)[0x7fc3a7ced30a]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Gui.so.5(_ZN8QPainter8fillRectERK5QRectRK6QBrush+0xc5)[0x7fc3a7d00165]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Widgets.so.5(_ZNK12QFusionStyle11drawControlEN6QStyle14ControlElementEPK12QStyleOptionP8QPainterPK7QWidget+0x3e06)[0x7fc3a83eb266]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Widgets.so.5(+0x20a1a3)[0x7fc3a83c11a3]
QMutex: destroying locked mutex
lib: 1
lic: 1

CoppeliaSim Edu V4.0.0. (rev. 4)
Using the default Lua library.
Loaded the video compression library.
Add-on script 'simAddOnScript-addOnScriptDemo.lua' was loaded.
Add-on script 'simAddOnScript-b0RemoteApiServer.lua' was loaded.
Add-on script 'simAddOnScript_PyRep.lua' was loaded.
If CoppeliaSim crashes now, try to install libgl1-mesa-dev on your system:
>sudo apt install libgl1-mesa-dev
OpenGL: Parallels and ATI Technologies Inc., Renderer: Parallels using AMD Radeon Pro 560X OpenGL Engine, Version: 2.1 ATI-3.5.5
...did not crash.
Simulator launched.
Plugin 'Geometric': loading...
Plugin 'Geometric': load succeeded.
Plugin 'Assimp': loading...
Plugin 'Assimp': warning: replaced variable 'simAssimp'
Plugin 'Assimp': load succeeded.
Plugin 'BlueZero': loading...
Plugin 'BlueZero': warning: replaced variable 'simB0'
Plugin 'BlueZero': load succeeded.
Plugin 'BubbleRob': loading...
Plugin 'BubbleRob': load succeeded.
Plugin 'Bwf': loading...
Plugin 'Bwf': load succeeded.
Plugin 'CodeEditor': loading...
Plugin 'CodeEditor': load succeeded.
Plugin 'Collada': loading...
Plugin 'Collada': load succeeded.
Plugin 'ConvexDecompose': loading...
Plugin 'ConvexDecompose': load succeeded.
Plugin 'CustomUI': loading...
Plugin 'CustomUI': warning: replaced variable 'simUI'
Plugin 'CustomUI': warning: replaced function 'simUI.insertTableRow@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.removeTableRow@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.insertTableColumn@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.removeTableColumn@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.setScene3DNodeParam@CustomUI'
Plugin 'CustomUI': load succeeded.
Plugin 'DynamicsBullet-2-78': loading...
Plugin 'DynamicsBullet-2-78': load succeeded.
Plugin 'DynamicsBullet-2-83': loading...
Plugin 'DynamicsBullet-2-83': load succeeded.
Plugin 'DynamicsNewton': loading...
Plugin 'DynamicsNewton': load succeeded.
Plugin 'DynamicsOde': loading...
Plugin 'DynamicsOde': load succeeded.
Plugin 'DynamicsVortex': loading...
Plugin 'DynamicsVortex': load succeeded.
Plugin 'ExternalRenderer': loading...
Plugin 'ExternalRenderer': load succeeded.
Plugin 'ICP': loading...
Plugin 'ICP': warning: replaced variable 'simICP'
Plugin 'ICP': load succeeded.
Plugin 'Image': loading...
Plugin 'Image': warning: replaced variable 'simIM'
Plugin 'Image': load succeeded.
Plugin 'K3': loading...
Plugin 'K3': load succeeded.
Plugin 'Lic': loading...
Plugin 'Lic': load succeeded.
Plugin 'LuaCommander': loading...
Plugin 'LuaCommander': warning: replaced variable 'simLuaCmd'
Plugin 'LuaCommander': load succeeded.
Plugin 'LuaRemoteApiClient': loading...
Plugin 'LuaRemoteApiClient': load succeeded.
Plugin 'Mtb': loading...
Plugin 'Mtb': load succeeded.
Plugin 'OMPL': loading...
Plugin 'OMPL': warning: replaced variable 'simOMPL'
Plugin 'OMPL': load succeeded.
Plugin 'OpenGL3Renderer': loading...
Plugin 'OpenGL3Renderer': load succeeded.
Plugin 'OpenMesh': loading...
Plugin 'OpenMesh': load succeeded.
Plugin 'Qhull': loading...
Plugin 'Qhull': load succeeded.
Plugin 'RRS1': loading...
Plugin 'RRS1': load succeeded.
Plugin 'ReflexxesTypeII': loading...
Plugin 'ReflexxesTypeII': load succeeded.
Plugin 'RemoteApi': loading...
Starting a remote API server on port 19997
Plugin 'RemoteApi': load succeeded.
Plugin 'SDF': loading...
Plugin 'SDF': warning: replaced variable 'simSDF'
Plugin 'SDF': load succeeded.
Plugin 'SurfaceReconstruction': loading...
Plugin 'SurfaceReconstruction': warning: replaced variable 'simSurfRec'
Plugin 'SurfaceReconstruction': load succeeded.
Plugin 'Urdf': loading...
Plugin 'Urdf': load succeeded.
Plugin 'Vision': loading...
Plugin 'Vision': load succeeded.
Using the 'Geometric' plugin.
Initializing the Bullet physics engine in plugin 'DynamicsBullet_2_83'...
Engine version: 2.83.7
Plugin version: 11
Initialization successful.
This renderer requires atleast OpenGL 3.2. The version available is: 2.1 ATI-3.5.5
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoords = aTexCoords;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:108: '(' : syntax error: Array size must appear after variable name

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

struct Material {
    vec4 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct DirLight {
    vec3 position; // specifically for shadows
    vec3 direction;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float farPlane;
    float bias;
    float normalBias;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

uniform sampler2D texture0;
uniform int textureApplyMode;

uniform vec3 sceneAmbient;
uniform vec3 viewPos;

// Some graphics cards appear not to support arrays. One way around this is to explicitly roll out the array.
#define MAX_LIGHTS 5
uniform DirLight dirLight0;
uniform DirLight dirLight1;
uniform DirLight dirLight2;
uniform DirLight dirLight3;
uniform DirLight dirLight4;

uniform PointLight pointLight0;
uniform PointLight pointLight1;
uniform PointLight pointLight2;
uniform PointLight pointLight3;
uniform PointLight pointLight4;

uniform SpotLight spotLight0;
uniform SpotLight spotLight1;
uniform SpotLight spotLight2;
uniform SpotLight spotLight3;
uniform SpotLight spotLight4;

// For some reason, we are not allowed to store samplerCube in structs or arrays
// So allow a max of 5
uniform samplerCube depthCubeMap0;
uniform samplerCube depthCubeMap1;
uniform samplerCube depthCubeMap2;
uniform samplerCube depthCubeMap3;
uniform samplerCube depthCubeMap4;

uniform int dirLightLen;
uniform int pointLightLen;
uniform int spotLightLen;

uniform Material material;

// array of offset direction for sampling in pointlight shadows
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1),
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

// function prototypes
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias);
float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias);

void main()
{
    // Lighting properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // Give it some intial ambient light
    vec4 ambient = texture(texture0, TexCoords);

    // textureApplyMode 1 (GL_DECAL) gets applied later.
    if (textureApplyMode == 2)  // ADD
        ambient = (ambient + material.ambient, 1.0) * vec4(sceneAmbient, 1.0);
    else if (textureApplyMode == 1)
        ambient = material.ambient;
    else if (textureApplyMode != 1)
        // In this case, we either have no texture, or we want to use GL_BLEND.
        ambient *= material.ambient * vec4(sceneAmbient, 1.0);

    vec3 result = vec3(0.0);
    // phase 1: directional lighting
    for(int i = 0; i < dirLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcDirLight(dirLight0, norm, viewDir);
            shadow = ShadowCalculation(dirLight0.lightSpaceMatrix, dirLight0.position, dirLight0.shadowMap, dirLight0.bias, dirLight0.normalBias);
        } else if (i == 1){
            lresult = CalcDirLight(dirLight1, norm, viewDir);
            shadow = ShadowCalculation(dirLight1.lightSpaceMatrix, dirLight1.position, dirLight1.shadowMap, dirLight1.bias, dirLight1.normalBias);
        } else if (i == 2){
            lresult = CalcDirLight(dirLight2, norm, viewDir);
            shadow = ShadowCalculation(dirLight2.lightSpaceMatrix, dirLight2.position, dirLight2.shadowMap, dirLight2.bias, dirLight2.normalBias);
        } else if (i == 3){
            lresult = CalcDirLight(dirLight3, norm, viewDir);
            shadow = ShadowCalculation(dirLight3.lightSpaceMatrix, dirLight3.position, dirLight3.shadowMap, dirLight3.bias, dirLight3.normalBias);
        } else if (i == 4){
            lresult = CalcDirLight(dirLight4, norm, viewDir);
            shadow = ShadowCalculation(dirLight4.lightSpaceMatrix, dirLight4.position, dirLight4.shadowMap, dirLight4.bias, dirLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 2: point lights
    for(int i = 0; i < pointLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;

        if (i == 0){
            lresult = CalcPointLight(pointLight0, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight0.position, depthCubeMap0, pointLight0.farPlane, pointLight0.bias, pointLight0.normalBias);
        }else if (i == 1){
            lresult = CalcPointLight(pointLight1, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight1.position, depthCubeMap1, pointLight1.farPlane, pointLight1.bias, pointLight1.normalBias);
        }else if (i == 2){
            lresult = CalcPointLight(pointLight2, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight2.position, depthCubeMap2, pointLight2.farPlane, pointLight2.bias, pointLight2.normalBias);
        }else if (i == 3){
            lresult = CalcPointLight(pointLight3, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight3.position, depthCubeMap3, pointLight3.farPlane, pointLight3.bias, pointLight3.normalBias);
        }else if (i == 4){
            lresult = CalcPointLight(pointLight4, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight4.position, depthCubeMap4, pointLight4.farPlane, pointLight4.bias, pointLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 3: spot light
    for(int i = 0; i < spotLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcSpotLight(spotLight0, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight0.lightSpaceMatrix, spotLight0.position, spotLight0.shadowMap, spotLight0.bias, spotLight0.normalBias);
        } else if (i == 1){
            lresult = CalcSpotLight(spotLight1, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight1.lightSpaceMatrix, spotLight1.position, spotLight1.shadowMap, spotLight1.bias, spotLight1.normalBias);
        } else if (i == 2){
            lresult = CalcSpotLight(spotLight2, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight2.lightSpaceMatrix, spotLight2.position, spotLight2.shadowMap, spotLight2.bias, spotLight2.normalBias);
        } else if (i == 3){
            lresult = CalcSpotLight(spotLight3, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight3.lightSpaceMatrix, spotLight3.position, spotLight3.shadowMap, spotLight3.bias, spotLight3.normalBias);
        } else if (i == 4){
            lresult = CalcSpotLight(spotLight4, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight4.lightSpaceMatrix, spotLight4.position, spotLight4.shadowMap, spotLight4.bias, spotLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }

    FragColor = ambient + vec4(result, 0.0);
    if (textureApplyMode == 1){
        // textureApplyMode == 1 is DECAL
        vec4 coltex = texture(texture0, TexCoords.st);
        vec3 col = FragColor.rgb * (1.0-coltex.a) + coltex.rgb * coltex.a;
        FragColor = vec4(col, FragColor.a);
    }
}

// calculates the color when using a directional light.
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading (Phong)
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    // specular shading (Blinn-Phong)
    // vec3 halfwayDir = normalize(lightDir + viewDir);
    // float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);

    // combine results
    vec3 diffuse = light.diffuse * (diff * (vec3(texture(texture0, TexCoords)) * material.diffuse));
    vec3 specular = light.specular * (spec * (vec3(texture(texture0, TexCoords)) * material.specular));
    return (diffuse + specular);
}

// calculates the color when using a point light.
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // combine results
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation;
    specular *= attenuation;
    return (diffuse + specular);
}

// calculates the color when using a spot light.
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);

    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results

    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;

    return (diffuse + specular);
}

float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias)
{
    vec4 fragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0);

    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    // check whether current frag pos is in shadow
    // PCF
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias)
{

    // get vector between fragment position and light position
    vec3 fragToLight = FragPos - lightPos;
    float currentDepth = length(fragToLight);

    float shadow = 0.0;

    // Bias calc
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    int samples = 20;
    float viewDistance = length(viewPos - FragPos);
    float diskRadius = (1.0 + (viewDistance / farPlane)) / 500.0;

    for(int i = 0; i < samples; i++)
    {
        float closestDepth = texture(cubeMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= farPlane;   // undo mapping [0;1]
        if((currentDepth - bias) > closestDepth){
            shadow += 1.0;
        }
    }
    shadow /= float(samples);
    return shadow;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:108: '(' : syntax error: Array size must appear after variable name\n"
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

uniform mat4 lightSpaceMatrix;
uniform mat4 model;

void main()
{
    gl_Position = lightSpaceMatrix * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

void main(void)
{
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\n"
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;

uniform mat4 model;

out vec3 FragPos;

uniform mat4 lightSpaceMatrix;

void main()
{
    gl_Position = lightSpaceMatrix * model * vec4(aPos, 1.0);
    FragPos = vec3(model * vec4(aPos, 1.0));
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1
in vec3 FragPos;

uniform vec3 lightPos;
uniform float far_plane;

void main()
{
    float lightDistance = length(FragPos - lightPos);

    // map to [0;1] range by dividing by far_plane
    lightDistance = lightDistance / far_plane;

    gl_FragDepth = lightDistance;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\n"
This renderer requires atleast OpenGL 3.2. The version available is: 2.1 ATI-3.5.5
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoords = aTexCoords;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:108: '(' : syntax error: Array size must appear after variable name

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

struct Material {
    vec4 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct DirLight {
    vec3 position; // specifically for shadows
    vec3 direction;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float farPlane;
    float bias;
    float normalBias;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

uniform sampler2D texture0;
uniform int textureApplyMode;

uniform vec3 sceneAmbient;
uniform vec3 viewPos;

// Some graphics cards appear not to support arrays. One way around this is to explicitly roll out the array.
#define MAX_LIGHTS 5
uniform DirLight dirLight0;
uniform DirLight dirLight1;
uniform DirLight dirLight2;
uniform DirLight dirLight3;
uniform DirLight dirLight4;

uniform PointLight pointLight0;
uniform PointLight pointLight1;
uniform PointLight pointLight2;
uniform PointLight pointLight3;
uniform PointLight pointLight4;

uniform SpotLight spotLight0;
uniform SpotLight spotLight1;
uniform SpotLight spotLight2;
uniform SpotLight spotLight3;
uniform SpotLight spotLight4;

// For some reason, we are not allowed to store samplerCube in structs or arrays
// So allow a max of 5
uniform samplerCube depthCubeMap0;
uniform samplerCube depthCubeMap1;
uniform samplerCube depthCubeMap2;
uniform samplerCube depthCubeMap3;
uniform samplerCube depthCubeMap4;

uniform int dirLightLen;
uniform int pointLightLen;
uniform int spotLightLen;

uniform Material material;

// array of offset direction for sampling in pointlight shadows
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1),
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

// function prototypes
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias);
float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias);

void main()
{
    // Lighting properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // Give it some intial ambient light
    vec4 ambient = texture(texture0, TexCoords);

    // textureApplyMode 1 (GL_DECAL) gets applied later.
    if (textureApplyMode == 2)  // ADD
        ambient = (ambient + material.ambient, 1.0) * vec4(sceneAmbient, 1.0);
    else if (textureApplyMode == 1)
        ambient = material.ambient;
    else if (textureApplyMode != 1)
        // In this case, we either have no texture, or we want to use GL_BLEND.
        ambient *= material.ambient * vec4(sceneAmbient, 1.0);

    vec3 result = vec3(0.0);
    // phase 1: directional lighting
    for(int i = 0; i < dirLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcDirLight(dirLight0, norm, viewDir);
            shadow = ShadowCalculation(dirLight0.lightSpaceMatrix, dirLight0.position, dirLight0.shadowMap, dirLight0.bias, dirLight0.normalBias);
        } else if (i == 1){
            lresult = CalcDirLight(dirLight1, norm, viewDir);
            shadow = ShadowCalculation(dirLight1.lightSpaceMatrix, dirLight1.position, dirLight1.shadowMap, dirLight1.bias, dirLight1.normalBias);
        } else if (i == 2){
            lresult = CalcDirLight(dirLight2, norm, viewDir);
            shadow = ShadowCalculation(dirLight2.lightSpaceMatrix, dirLight2.position, dirLight2.shadowMap, dirLight2.bias, dirLight2.normalBias);
        } else if (i == 3){
            lresult = CalcDirLight(dirLight3, norm, viewDir);
            shadow = ShadowCalculation(dirLight3.lightSpaceMatrix, dirLight3.position, dirLight3.shadowMap, dirLight3.bias, dirLight3.normalBias);
        } else if (i == 4){
            lresult = CalcDirLight(dirLight4, norm, viewDir);
            shadow = ShadowCalculation(dirLight4.lightSpaceMatrix, dirLight4.position, dirLight4.shadowMap, dirLight4.bias, dirLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 2: point lights
    for(int i = 0; i < pointLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;

        if (i == 0){
            lresult = CalcPointLight(pointLight0, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight0.position, depthCubeMap0, pointLight0.farPlane, pointLight0.bias, pointLight0.normalBias);
        }else if (i == 1){
            lresult = CalcPointLight(pointLight1, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight1.position, depthCubeMap1, pointLight1.farPlane, pointLight1.bias, pointLight1.normalBias);
        }else if (i == 2){
            lresult = CalcPointLight(pointLight2, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight2.position, depthCubeMap2, pointLight2.farPlane, pointLight2.bias, pointLight2.normalBias);
        }else if (i == 3){
            lresult = CalcPointLight(pointLight3, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight3.position, depthCubeMap3, pointLight3.farPlane, pointLight3.bias, pointLight3.normalBias);
        }else if (i == 4){
            lresult = CalcPointLight(pointLight4, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight4.position, depthCubeMap4, pointLight4.farPlane, pointLight4.bias, pointLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 3: spot light
    for(int i = 0; i < spotLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcSpotLight(spotLight0, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight0.lightSpaceMatrix, spotLight0.position, spotLight0.shadowMap, spotLight0.bias, spotLight0.normalBias);
        } else if (i == 1){
            lresult = CalcSpotLight(spotLight1, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight1.lightSpaceMatrix, spotLight1.position, spotLight1.shadowMap, spotLight1.bias, spotLight1.normalBias);
        } else if (i == 2){
            lresult = CalcSpotLight(spotLight2, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight2.lightSpaceMatrix, spotLight2.position, spotLight2.shadowMap, spotLight2.bias, spotLight2.normalBias);
        } else if (i == 3){
            lresult = CalcSpotLight(spotLight3, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight3.lightSpaceMatrix, spotLight3.position, spotLight3.shadowMap, spotLight3.bias, spotLight3.normalBias);
        } else if (i == 4){
            lresult = CalcSpotLight(spotLight4, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight4.lightSpaceMatrix, spotLight4.position, spotLight4.shadowMap, spotLight4.bias, spotLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }

    FragColor = ambient + vec4(result, 0.0);
    if (textureApplyMode == 1){
        // textureApplyMode == 1 is DECAL
        vec4 coltex = texture(texture0, TexCoords.st);
        vec3 col = FragColor.rgb * (1.0-coltex.a) + coltex.rgb * coltex.a;
        FragColor = vec4(col, FragColor.a);
    }
}

// calculates the color when using a directional light.
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading (Phong)
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    // specular shading (Blinn-Phong)
    // vec3 halfwayDir = normalize(lightDir + viewDir);
    // float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);

    // combine results
    vec3 diffuse = light.diffuse * (diff * (vec3(texture(texture0, TexCoords)) * material.diffuse));
    vec3 specular = light.specular * (spec * (vec3(texture(texture0, TexCoords)) * material.specular));
    return (diffuse + specular);
}

// calculates the color when using a point light.
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // combine results
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation;
    specular *= attenuation;
    return (diffuse + specular);
}

// calculates the color when using a spot light.
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);

    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results

    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;

    return (diffuse + specular);
}

float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias)
{
    vec4 fragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0);

    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    // check whether current frag pos is in shadow
    // PCF
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias)
{

    // get vector between fragment position and light position
    vec3 fragToLight = FragPos - lightPos;
    float currentDepth = length(fragToLight);

    float shadow = 0.0;

    // Bias calc
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    int samples = 20;
    float viewDistance = length(viewPos - FragPos);
    float diskRadius = (1.0 + (viewDistance / farPlane)) / 500.0;

    for(int i = 0; i < samples; i++)
    {
        float closestDepth = texture(cubeMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= farPlane;   // undo mapping [0;1]
        if((currentDepth - bias) > closestDepth){
            shadow += 1.0;
        }
    }
    shadow /= float(samples);
    return shadow;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:108: '(' : syntax error: Array size must appear after variable name\n"
This renderer requires atleast OpenGL 3.2. The version available is: 2.1 ATI-3.5.5
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoords = aTexCoords;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:108: '(' : syntax error: Array size must appear after variable name

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

struct Material {
    vec4 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct DirLight {
    vec3 position; // specifically for shadows
    vec3 direction;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float farPlane;
    float bias;
    float normalBias;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

uniform sampler2D texture0;
uniform int textureApplyMode;

uniform vec3 sceneAmbient;
uniform vec3 viewPos;

// Some graphics cards appear not to support arrays. One way around this is to explicitly roll out the array.
#define MAX_LIGHTS 5
uniform DirLight dirLight0;
uniform DirLight dirLight1;
uniform DirLight dirLight2;
uniform DirLight dirLight3;
uniform DirLight dirLight4;

uniform PointLight pointLight0;
uniform PointLight pointLight1;
uniform PointLight pointLight2;
uniform PointLight pointLight3;
uniform PointLight pointLight4;

uniform SpotLight spotLight0;
uniform SpotLight spotLight1;
uniform SpotLight spotLight2;
uniform SpotLight spotLight3;
uniform SpotLight spotLight4;

// For some reason, we are not allowed to store samplerCube in structs or arrays
// So allow a max of 5
uniform samplerCube depthCubeMap0;
uniform samplerCube depthCubeMap1;
uniform samplerCube depthCubeMap2;
uniform samplerCube depthCubeMap3;
uniform samplerCube depthCubeMap4;

uniform int dirLightLen;
uniform int pointLightLen;
uniform int spotLightLen;

uniform Material material;

// array of offset direction for sampling in pointlight shadows
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1),
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

// function prototypes
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias);
float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias);

void main()
{
    // Lighting properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // Give it some intial ambient light
    vec4 ambient = texture(texture0, TexCoords);

    // textureApplyMode 1 (GL_DECAL) gets applied later.
    if (textureApplyMode == 2)  // ADD
        ambient = (ambient + material.ambient, 1.0) * vec4(sceneAmbient, 1.0);
    else if (textureApplyMode == 1)
        ambient = material.ambient;
    else if (textureApplyMode != 1)
        // In this case, we either have no texture, or we want to use GL_BLEND.
        ambient *= material.ambient * vec4(sceneAmbient, 1.0);

    vec3 result = vec3(0.0);
    // phase 1: directional lighting
    for(int i = 0; i < dirLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcDirLight(dirLight0, norm, viewDir);
            shadow = ShadowCalculation(dirLight0.lightSpaceMatrix, dirLight0.position, dirLight0.shadowMap, dirLight0.bias, dirLight0.normalBias);
        } else if (i == 1){
            lresult = CalcDirLight(dirLight1, norm, viewDir);
            shadow = ShadowCalculation(dirLight1.lightSpaceMatrix, dirLight1.position, dirLight1.shadowMap, dirLight1.bias, dirLight1.normalBias);
        } else if (i == 2){
            lresult = CalcDirLight(dirLight2, norm, viewDir);
            shadow = ShadowCalculation(dirLight2.lightSpaceMatrix, dirLight2.position, dirLight2.shadowMap, dirLight2.bias, dirLight2.normalBias);
        } else if (i == 3){
            lresult = CalcDirLight(dirLight3, norm, viewDir);
            shadow = ShadowCalculation(dirLight3.lightSpaceMatrix, dirLight3.position, dirLight3.shadowMap, dirLight3.bias, dirLight3.normalBias);
        } else if (i == 4){
            lresult = CalcDirLight(dirLight4, norm, viewDir);
            shadow = ShadowCalculation(dirLight4.lightSpaceMatrix, dirLight4.position, dirLight4.shadowMap, dirLight4.bias, dirLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 2: point lights
    for(int i = 0; i < pointLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;

        if (i == 0){
            lresult = CalcPointLight(pointLight0, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight0.position, depthCubeMap0, pointLight0.farPlane, pointLight0.bias, pointLight0.normalBias);
        }else if (i == 1){
            lresult = CalcPointLight(pointLight1, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight1.position, depthCubeMap1, pointLight1.farPlane, pointLight1.bias, pointLight1.normalBias);
        }else if (i == 2){
            lresult = CalcPointLight(pointLight2, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight2.position, depthCubeMap2, pointLight2.farPlane, pointLight2.bias, pointLight2.normalBias);
        }else if (i == 3){
            lresult = CalcPointLight(pointLight3, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight3.position, depthCubeMap3, pointLight3.farPlane, pointLight3.bias, pointLight3.normalBias);
        }else if (i == 4){
            lresult = CalcPointLight(pointLight4, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight4.position, depthCubeMap4, pointLight4.farPlane, pointLight4.bias, pointLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 3: spot light
    for(int i = 0; i < spotLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcSpotLight(spotLight0, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight0.lightSpaceMatrix, spotLight0.position, spotLight0.shadowMap, spotLight0.bias, spotLight0.normalBias);
        } else if (i == 1){
            lresult = CalcSpotLight(spotLight1, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight1.lightSpaceMatrix, spotLight1.position, spotLight1.shadowMap, spotLight1.bias, spotLight1.normalBias);
        } else if (i == 2){
            lresult = CalcSpotLight(spotLight2, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight2.lightSpaceMatrix, spotLight2.position, spotLight2.shadowMap, spotLight2.bias, spotLight2.normalBias);
        } else if (i == 3){
            lresult = CalcSpotLight(spotLight3, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight3.lightSpaceMatrix, spotLight3.position, spotLight3.shadowMap, spotLight3.bias, spotLight3.normalBias);
        } else if (i == 4){
            lresult = CalcSpotLight(spotLight4, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight4.lightSpaceMatrix, spotLight4.position, spotLight4.shadowMap, spotLight4.bias, spotLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }

    FragColor = ambient + vec4(result, 0.0);
    if (textureApplyMode == 1){
        // textureApplyMode == 1 is DECAL
        vec4 coltex = texture(texture0, TexCoords.st);
        vec3 col = FragColor.rgb * (1.0-coltex.a) + coltex.rgb * coltex.a;
        FragColor = vec4(col, FragColor.a);
    }
}

// calculates the color when using a directional light.
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading (Phong)
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    // specular shading (Blinn-Phong)
    // vec3 halfwayDir = normalize(lightDir + viewDir);
    // float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);

    // combine results
    vec3 diffuse = light.diffuse * (diff * (vec3(texture(texture0, TexCoords)) * material.diffuse));
    vec3 specular = light.specular * (spec * (vec3(texture(texture0, TexCoords)) * material.specular));
    return (diffuse + specular);
}

// calculates the color when using a point light.
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // combine results
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation;
    specular *= attenuation;
    return (diffuse + specular);
}

// calculates the color when using a spot light.
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);

    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results

    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;

    return (diffuse + specular);
}

float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias)
{
    vec4 fragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0);

    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    // check whether current frag pos is in shadow
    // PCF
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias)
{

    // get vector between fragment position and light position
    vec3 fragToLight = FragPos - lightPos;
    float currentDepth = length(fragToLight);

    float shadow = 0.0;

    // Bias calc
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    int samples = 20;
    float viewDistance = length(viewPos - FragPos);
    float diskRadius = (1.0 + (viewDistance / farPlane)) / 500.0;

    for(int i = 0; i < samples; i++)
    {
        float closestDepth = texture(cubeMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= farPlane;   // undo mapping [0;1]
        if((currentDepth - bias) > closestDepth){
            shadow += 1.0;
        }
    }
    shadow /= float(samples);
    return shadow;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:108: '(' : syntax error: Array size must appear after variable name\n"
Actor(
  (backbones): Backbones(
    (hidden): ModuleList(
      (0): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (1): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (2): Sequential(
        (0): Linear(in_features=3, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
    )
    (cnn_tail): ModuleList()
  )
  (fc_body): Sequential(
    (0): Linear(in_features=96, out_features=128, bias=True)
    (1): LeakyReLU(negative_slope=0.01, inplace=True)
    (2): Linear(in_features=128, out_features=128, bias=True)
    (3): LeakyReLU(negative_slope=0.01, inplace=True)
    (4): Linear(in_features=128, out_features=8, bias=True)
    (5): Tanh()
  )
)
Critic(
  (backbones): Backbones(
    (hidden): ModuleList(
      (0): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (1): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (2): Sequential(
        (0): Linear(in_features=3, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
    )
    (cnn_tail): ModuleList()
  )
  (fc_body): Sequential(
    (0): Linear(in_features=96, out_features=128, bias=True)
    (1): LeakyReLU(negative_slope=0.01, inplace=True)
  )
  (critic_body): Sequential(
    (0): Linear(in_features=136, out_features=64, bias=True)
    (1): LeakyReLU(negative_slope=0.01, inplace=True)
    (2): Linear(in_features=64, out_features=1, bias=True)
  )
)
Episode 1	Exploration: 0.799000	Average Score: -0.70	Current Score: -0.70	Actor Loss: 0.00e+00	Critic Loss: 0.00e+00
Episode 2	Exploration: 0.798000	Average Score: -0.76	Current Score: -0.81	Actor Loss: 0.00e+00	Critic Loss: 0.00e+00
Episode 3	Exploration: 0.797000	Average Score: -0.67	Current Score: -0.51	Actor Loss: 7.00e-01	Critic Loss: 2.85e-02
Episode 4	Exploration: 0.796000	Average Score: -0.67	Current Score: -0.67	Actor Loss: 5.81e-01	Critic Loss: 7.37e-03
Episode 5	Exploration: 0.795000	Average Score: -0.63	Current Score: -0.46	Actor Loss: 5.38e-01	Critic Loss: 4.96e-03
Episode 6	Exploration: 0.794000	Average Score: -0.67	Current Score: -0.88	Actor Loss: 6.33e-01	Critic Loss: 4.17e-03
Episode 7	Exploration: 0.793000	Average Score: -0.70	Current Score: -0.87	Actor Loss: 6.82e-01	Critic Loss: 6.28e-03
Episode 8	Exploration: 0.792000	Average Score: -0.70	Current Score: -0.72	Actor Loss: 7.48e-01	Critic Loss: 7.96e-03
Episode 9	Exploration: 0.791000	Average Score: -0.69	Current Score: -0.60	Actor Loss: 7.80e-01	Critic Loss: 7.20e-03
Episode 10	Exploration: 0.790000	Average Score: -0.70	Current Score: -0.79	Actor Loss: 6.25e-01	Critic Loss: 2.88e-03
qt.qpa.xkeyboard: failed to compile a keymap
Episode 11	Exploration: 0.789000	Average Score: -0.69	Current Score: -0.53	Actor Loss: 6.80e-01	Critic Loss: 3.65e-03
/home/zhenwang/code/git/robotics/PyRep/pyrep/pyrep.py:209: UserWarning: Could not change simulation timestep. You may need to change it to "custom dt" using simulation settings dialog.
  warnings.warn('Could not change simulation timestep. You may need '
/home/zhenwang/software/anaconda3/envs/robotics/lib/python3.7/site-packages/gym/logger.py:30: UserWarning: [33mWARN: Box bound precision lowered by casting to float32[0m
  warnings.warn(colorize('%s: %s'%('WARN', msg % args), 'yellow'))
Traceback (most recent call last):
  File "single_task_rl_ddpg.py", line 113, in <module>
    max_t=MAX_STEPS, learn_every_step=LEARN_EVERY_STEP)
  File "single_task_rl_ddpg.py", line 38, in ddpg
    next_state, reward, terminate, _ = env.step(action)
  File "/home/zhenwang/code/git/robotics/RLBench/examples/ddpg/rlbench_env.py", line 101, in step
    obs, reward, terminate = self.task.step(action)  # reward in original rlbench is binary for success or not
  File "/home/zhenwang/software/anaconda3/envs/robotics/lib/python3.7/site-packages/rlbench/task_environment.py", line 235, in step
    return self._scene.get_observation(), int(success), terminate
  File "/home/zhenwang/software/anaconda3/envs/robotics/lib/python3.7/site-packages/rlbench/backend/scene.py", line 143, in get_observation
    fs = self._robot.arm.get_joint_forces()
  File "/home/zhenwang/code/git/robotics/PyRep/pyrep/robots/robot_component.py", line 162, in get_joint_forces
    return [j.get_joint_force() for j in self.joints]
  File "/home/zhenwang/code/git/robotics/PyRep/pyrep/robots/robot_component.py", line 162, in <listcomp>
    return [j.get_joint_force() for j in self.joints]
  File "/home/zhenwang/code/git/robotics/PyRep/pyrep/objects/joint.py", line 123, in get_joint_force
    return sim.simGetJointForce(self._handle)
  File "/home/zhenwang/code/git/robotics/PyRep/pyrep/backend/sim.py", line 169, in simGetJointForce
    raise RuntimeError('No value available yet.')
RuntimeError: No value available yet.


Error: signal 11:

/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libcoppeliaSim.so.1(_Z11_segHandleri+0x2b)[0x7ff1781d20bb]
/lib/x86_64-linux-gnu/libc.so.6(+0x3ef20)[0x7ff187380f20]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Core.so.5(_ZN6QMutex4lockEv+0x15)[0x7ff176042375]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Gui.so.5(+0x387b0e)[0x7ff176cd5b0e]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Gui.so.5(+0x37f3cf)[0x7ff176ccd3cf]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Gui.so.5(_ZN18QRasterPaintEngine11updateBrushERK6QBrush+0x87)[0x7ff176cd0837]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Gui.so.5(_ZN18QRasterPaintEngine8fillRectERK6QRectFRK6QBrush+0x2a)[0x7ff176cd130a]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Gui.so.5(_ZN8QPainter8fillRectERK5QRectRK6QBrush+0xc5)[0x7ff176ce4165]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Widgets.so.5(_ZNK12QFusionStyle11drawControlEN6QStyle14ControlElementEPK12QStyleOptionP8QPainterPK7QWidget+0x2da7)[0x7ff1773ce207]
/home/zhenwang/software/CoppeliaSim_Edu_V4_0_0_Ubuntu18_04/libQt5Widgets.so.5(+0x20a3ee)[0x7ff1773a53ee]
QMutex: destroying locked mutex
lib: 1
lic: 1

CoppeliaSim Edu V4.0.0. (rev. 4)
Using the default Lua library.
Loaded the video compression library.
Add-on script 'simAddOnScript-addOnScriptDemo.lua' was loaded.
Add-on script 'simAddOnScript-b0RemoteApiServer.lua' was loaded.
Add-on script 'simAddOnScript_PyRep.lua' was loaded.
If CoppeliaSim crashes now, try to install libgl1-mesa-dev on your system:
>sudo apt install libgl1-mesa-dev
OpenGL: Parallels and ATI Technologies Inc., Renderer: Parallels using AMD Radeon Pro 560X OpenGL Engine, Version: 2.1 ATI-3.5.5
...did not crash.
Simulator launched.
Plugin 'Geometric': loading...
Plugin 'Geometric': load succeeded.
Plugin 'Assimp': loading...
Plugin 'Assimp': warning: replaced variable 'simAssimp'
Plugin 'Assimp': load succeeded.
Plugin 'BlueZero': loading...
Plugin 'BlueZero': warning: replaced variable 'simB0'
Plugin 'BlueZero': load succeeded.
Plugin 'BubbleRob': loading...
Plugin 'BubbleRob': load succeeded.
Plugin 'Bwf': loading...
Plugin 'Bwf': load succeeded.
Plugin 'CodeEditor': loading...
Plugin 'CodeEditor': load succeeded.
Plugin 'Collada': loading...
Plugin 'Collada': load succeeded.
Plugin 'ConvexDecompose': loading...
Plugin 'ConvexDecompose': load succeeded.
Plugin 'CustomUI': loading...
Plugin 'CustomUI': warning: replaced variable 'simUI'
Plugin 'CustomUI': warning: replaced function 'simUI.insertTableRow@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.removeTableRow@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.insertTableColumn@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.removeTableColumn@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.setScene3DNodeParam@CustomUI'
Plugin 'CustomUI': load succeeded.
Plugin 'DynamicsBullet-2-78': loading...
Plugin 'DynamicsBullet-2-78': load succeeded.
Plugin 'DynamicsBullet-2-83': loading...
Plugin 'DynamicsBullet-2-83': load succeeded.
Plugin 'DynamicsNewton': loading...
Plugin 'DynamicsNewton': load succeeded.
Plugin 'DynamicsOde': loading...
Plugin 'DynamicsOde': load succeeded.
Plugin 'DynamicsVortex': loading...
Plugin 'DynamicsVortex': load succeeded.
Plugin 'ExternalRenderer': loading...
Plugin 'ExternalRenderer': load succeeded.
Plugin 'ICP': loading...
Plugin 'ICP': warning: replaced variable 'simICP'
Plugin 'ICP': load succeeded.
Plugin 'Image': loading...
Plugin 'Image': warning: replaced variable 'simIM'
Plugin 'Image': load succeeded.
Plugin 'K3': loading...
Plugin 'K3': load succeeded.
Plugin 'Lic': loading...
Plugin 'Lic': load succeeded.
Plugin 'LuaCommander': loading...
Plugin 'LuaCommander': warning: replaced variable 'simLuaCmd'
Plugin 'LuaCommander': load succeeded.
Plugin 'LuaRemoteApiClient': loading...
Plugin 'LuaRemoteApiClient': load succeeded.
Plugin 'Mtb': loading...
Plugin 'Mtb': load succeeded.
Plugin 'OMPL': loading...
Plugin 'OMPL': warning: replaced variable 'simOMPL'
Plugin 'OMPL': load succeeded.
Plugin 'OpenGL3Renderer': loading...
Plugin 'OpenGL3Renderer': load succeeded.
Plugin 'OpenMesh': loading...
Plugin 'OpenMesh': load succeeded.
Plugin 'Qhull': loading...
Plugin 'Qhull': load succeeded.
Plugin 'RRS1': loading...
Plugin 'RRS1': load succeeded.
Plugin 'ReflexxesTypeII': loading...
Plugin 'ReflexxesTypeII': load succeeded.
Plugin 'RemoteApi': loading...
Starting a remote API server on port 19997
Plugin 'RemoteApi': load succeeded.
Plugin 'SDF': loading...
Plugin 'SDF': warning: replaced variable 'simSDF'
Plugin 'SDF': load succeeded.
Plugin 'SurfaceReconstruction': loading...
Plugin 'SurfaceReconstruction': warning: replaced variable 'simSurfRec'
Plugin 'SurfaceReconstruction': load succeeded.
Plugin 'Urdf': loading...
Plugin 'Urdf': load succeeded.
Plugin 'Vision': loading...
Plugin 'Vision': load succeeded.
Using the 'Geometric' plugin.
Initializing the Bullet physics engine in plugin 'DynamicsBullet_2_83'...
Engine version: 2.83.7
Plugin version: 11
Initialization successful.
This renderer requires atleast OpenGL 3.2. The version available is: 2.1 ATI-3.5.5
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoords = aTexCoords;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:108: '(' : syntax error: Array size must appear after variable name

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

struct Material {
    vec4 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct DirLight {
    vec3 position; // specifically for shadows
    vec3 direction;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float farPlane;
    float bias;
    float normalBias;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

uniform sampler2D texture0;
uniform int textureApplyMode;

uniform vec3 sceneAmbient;
uniform vec3 viewPos;

// Some graphics cards appear not to support arrays. One way around this is to explicitly roll out the array.
#define MAX_LIGHTS 5
uniform DirLight dirLight0;
uniform DirLight dirLight1;
uniform DirLight dirLight2;
uniform DirLight dirLight3;
uniform DirLight dirLight4;

uniform PointLight pointLight0;
uniform PointLight pointLight1;
uniform PointLight pointLight2;
uniform PointLight pointLight3;
uniform PointLight pointLight4;

uniform SpotLight spotLight0;
uniform SpotLight spotLight1;
uniform SpotLight spotLight2;
uniform SpotLight spotLight3;
uniform SpotLight spotLight4;

// For some reason, we are not allowed to store samplerCube in structs or arrays
// So allow a max of 5
uniform samplerCube depthCubeMap0;
uniform samplerCube depthCubeMap1;
uniform samplerCube depthCubeMap2;
uniform samplerCube depthCubeMap3;
uniform samplerCube depthCubeMap4;

uniform int dirLightLen;
uniform int pointLightLen;
uniform int spotLightLen;

uniform Material material;

// array of offset direction for sampling in pointlight shadows
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1),
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

// function prototypes
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias);
float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias);

void main()
{
    // Lighting properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // Give it some intial ambient light
    vec4 ambient = texture(texture0, TexCoords);

    // textureApplyMode 1 (GL_DECAL) gets applied later.
    if (textureApplyMode == 2)  // ADD
        ambient = (ambient + material.ambient, 1.0) * vec4(sceneAmbient, 1.0);
    else if (textureApplyMode == 1)
        ambient = material.ambient;
    else if (textureApplyMode != 1)
        // In this case, we either have no texture, or we want to use GL_BLEND.
        ambient *= material.ambient * vec4(sceneAmbient, 1.0);

    vec3 result = vec3(0.0);
    // phase 1: directional lighting
    for(int i = 0; i < dirLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcDirLight(dirLight0, norm, viewDir);
            shadow = ShadowCalculation(dirLight0.lightSpaceMatrix, dirLight0.position, dirLight0.shadowMap, dirLight0.bias, dirLight0.normalBias);
        } else if (i == 1){
            lresult = CalcDirLight(dirLight1, norm, viewDir);
            shadow = ShadowCalculation(dirLight1.lightSpaceMatrix, dirLight1.position, dirLight1.shadowMap, dirLight1.bias, dirLight1.normalBias);
        } else if (i == 2){
            lresult = CalcDirLight(dirLight2, norm, viewDir);
            shadow = ShadowCalculation(dirLight2.lightSpaceMatrix, dirLight2.position, dirLight2.shadowMap, dirLight2.bias, dirLight2.normalBias);
        } else if (i == 3){
            lresult = CalcDirLight(dirLight3, norm, viewDir);
            shadow = ShadowCalculation(dirLight3.lightSpaceMatrix, dirLight3.position, dirLight3.shadowMap, dirLight3.bias, dirLight3.normalBias);
        } else if (i == 4){
            lresult = CalcDirLight(dirLight4, norm, viewDir);
            shadow = ShadowCalculation(dirLight4.lightSpaceMatrix, dirLight4.position, dirLight4.shadowMap, dirLight4.bias, dirLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 2: point lights
    for(int i = 0; i < pointLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;

        if (i == 0){
            lresult = CalcPointLight(pointLight0, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight0.position, depthCubeMap0, pointLight0.farPlane, pointLight0.bias, pointLight0.normalBias);
        }else if (i == 1){
            lresult = CalcPointLight(pointLight1, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight1.position, depthCubeMap1, pointLight1.farPlane, pointLight1.bias, pointLight1.normalBias);
        }else if (i == 2){
            lresult = CalcPointLight(pointLight2, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight2.position, depthCubeMap2, pointLight2.farPlane, pointLight2.bias, pointLight2.normalBias);
        }else if (i == 3){
            lresult = CalcPointLight(pointLight3, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight3.position, depthCubeMap3, pointLight3.farPlane, pointLight3.bias, pointLight3.normalBias);
        }else if (i == 4){
            lresult = CalcPointLight(pointLight4, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight4.position, depthCubeMap4, pointLight4.farPlane, pointLight4.bias, pointLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 3: spot light
    for(int i = 0; i < spotLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcSpotLight(spotLight0, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight0.lightSpaceMatrix, spotLight0.position, spotLight0.shadowMap, spotLight0.bias, spotLight0.normalBias);
        } else if (i == 1){
            lresult = CalcSpotLight(spotLight1, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight1.lightSpaceMatrix, spotLight1.position, spotLight1.shadowMap, spotLight1.bias, spotLight1.normalBias);
        } else if (i == 2){
            lresult = CalcSpotLight(spotLight2, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight2.lightSpaceMatrix, spotLight2.position, spotLight2.shadowMap, spotLight2.bias, spotLight2.normalBias);
        } else if (i == 3){
            lresult = CalcSpotLight(spotLight3, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight3.lightSpaceMatrix, spotLight3.position, spotLight3.shadowMap, spotLight3.bias, spotLight3.normalBias);
        } else if (i == 4){
            lresult = CalcSpotLight(spotLight4, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight4.lightSpaceMatrix, spotLight4.position, spotLight4.shadowMap, spotLight4.bias, spotLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }

    FragColor = ambient + vec4(result, 0.0);
    if (textureApplyMode == 1){
        // textureApplyMode == 1 is DECAL
        vec4 coltex = texture(texture0, TexCoords.st);
        vec3 col = FragColor.rgb * (1.0-coltex.a) + coltex.rgb * coltex.a;
        FragColor = vec4(col, FragColor.a);
    }
}

// calculates the color when using a directional light.
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading (Phong)
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    // specular shading (Blinn-Phong)
    // vec3 halfwayDir = normalize(lightDir + viewDir);
    // float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);

    // combine results
    vec3 diffuse = light.diffuse * (diff * (vec3(texture(texture0, TexCoords)) * material.diffuse));
    vec3 specular = light.specular * (spec * (vec3(texture(texture0, TexCoords)) * material.specular));
    return (diffuse + specular);
}

// calculates the color when using a point light.
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // combine results
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation;
    specular *= attenuation;
    return (diffuse + specular);
}

// calculates the color when using a spot light.
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);

    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results

    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;

    return (diffuse + specular);
}

float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias)
{
    vec4 fragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0);

    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    // check whether current frag pos is in shadow
    // PCF
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias)
{

    // get vector between fragment position and light position
    vec3 fragToLight = FragPos - lightPos;
    float currentDepth = length(fragToLight);

    float shadow = 0.0;

    // Bias calc
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    int samples = 20;
    float viewDistance = length(viewPos - FragPos);
    float diskRadius = (1.0 + (viewDistance / farPlane)) / 500.0;

    for(int i = 0; i < samples; i++)
    {
        float closestDepth = texture(cubeMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= farPlane;   // undo mapping [0;1]
        if((currentDepth - bias) > closestDepth){
            shadow += 1.0;
        }
    }
    shadow /= float(samples);
    return shadow;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:108: '(' : syntax error: Array size must appear after variable name\n"
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

uniform mat4 lightSpaceMatrix;
uniform mat4 model;

void main()
{
    gl_Position = lightSpaceMatrix * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

void main(void)
{
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\n"
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;

uniform mat4 model;

out vec3 FragPos;

uniform mat4 lightSpaceMatrix;

void main()
{
    gl_Position = lightSpaceMatrix * model * vec4(aPos, 1.0);
    FragPos = vec3(model * vec4(aPos, 1.0));
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1
in vec3 FragPos;

uniform vec3 lightPos;
uniform float far_plane;

void main()
{
    float lightDistance = length(FragPos - lightPos);

    // map to [0;1] range by dividing by far_plane
    lightDistance = lightDistance / far_plane;

    gl_FragDepth = lightDistance;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\n"
This renderer requires atleast OpenGL 3.2. The version available is: 2.1 ATI-3.5.5
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoords = aTexCoords;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:108: '(' : syntax error: Array size must appear after variable name

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

struct Material {
    vec4 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct DirLight {
    vec3 position; // specifically for shadows
    vec3 direction;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float farPlane;
    float bias;
    float normalBias;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

uniform sampler2D texture0;
uniform int textureApplyMode;

uniform vec3 sceneAmbient;
uniform vec3 viewPos;

// Some graphics cards appear not to support arrays. One way around this is to explicitly roll out the array.
#define MAX_LIGHTS 5
uniform DirLight dirLight0;
uniform DirLight dirLight1;
uniform DirLight dirLight2;
uniform DirLight dirLight3;
uniform DirLight dirLight4;

uniform PointLight pointLight0;
uniform PointLight pointLight1;
uniform PointLight pointLight2;
uniform PointLight pointLight3;
uniform PointLight pointLight4;

uniform SpotLight spotLight0;
uniform SpotLight spotLight1;
uniform SpotLight spotLight2;
uniform SpotLight spotLight3;
uniform SpotLight spotLight4;

// For some reason, we are not allowed to store samplerCube in structs or arrays
// So allow a max of 5
uniform samplerCube depthCubeMap0;
uniform samplerCube depthCubeMap1;
uniform samplerCube depthCubeMap2;
uniform samplerCube depthCubeMap3;
uniform samplerCube depthCubeMap4;

uniform int dirLightLen;
uniform int pointLightLen;
uniform int spotLightLen;

uniform Material material;

// array of offset direction for sampling in pointlight shadows
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1),
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

// function prototypes
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias);
float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias);

void main()
{
    // Lighting properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // Give it some intial ambient light
    vec4 ambient = texture(texture0, TexCoords);

    // textureApplyMode 1 (GL_DECAL) gets applied later.
    if (textureApplyMode == 2)  // ADD
        ambient = (ambient + material.ambient, 1.0) * vec4(sceneAmbient, 1.0);
    else if (textureApplyMode == 1)
        ambient = material.ambient;
    else if (textureApplyMode != 1)
        // In this case, we either have no texture, or we want to use GL_BLEND.
        ambient *= material.ambient * vec4(sceneAmbient, 1.0);

    vec3 result = vec3(0.0);
    // phase 1: directional lighting
    for(int i = 0; i < dirLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcDirLight(dirLight0, norm, viewDir);
            shadow = ShadowCalculation(dirLight0.lightSpaceMatrix, dirLight0.position, dirLight0.shadowMap, dirLight0.bias, dirLight0.normalBias);
        } else if (i == 1){
            lresult = CalcDirLight(dirLight1, norm, viewDir);
            shadow = ShadowCalculation(dirLight1.lightSpaceMatrix, dirLight1.position, dirLight1.shadowMap, dirLight1.bias, dirLight1.normalBias);
        } else if (i == 2){
            lresult = CalcDirLight(dirLight2, norm, viewDir);
            shadow = ShadowCalculation(dirLight2.lightSpaceMatrix, dirLight2.position, dirLight2.shadowMap, dirLight2.bias, dirLight2.normalBias);
        } else if (i == 3){
            lresult = CalcDirLight(dirLight3, norm, viewDir);
            shadow = ShadowCalculation(dirLight3.lightSpaceMatrix, dirLight3.position, dirLight3.shadowMap, dirLight3.bias, dirLight3.normalBias);
        } else if (i == 4){
            lresult = CalcDirLight(dirLight4, norm, viewDir);
            shadow = ShadowCalculation(dirLight4.lightSpaceMatrix, dirLight4.position, dirLight4.shadowMap, dirLight4.bias, dirLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 2: point lights
    for(int i = 0; i < pointLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;

        if (i == 0){
            lresult = CalcPointLight(pointLight0, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight0.position, depthCubeMap0, pointLight0.farPlane, pointLight0.bias, pointLight0.normalBias);
        }else if (i == 1){
            lresult = CalcPointLight(pointLight1, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight1.position, depthCubeMap1, pointLight1.farPlane, pointLight1.bias, pointLight1.normalBias);
        }else if (i == 2){
            lresult = CalcPointLight(pointLight2, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight2.position, depthCubeMap2, pointLight2.farPlane, pointLight2.bias, pointLight2.normalBias);
        }else if (i == 3){
            lresult = CalcPointLight(pointLight3, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight3.position, depthCubeMap3, pointLight3.farPlane, pointLight3.bias, pointLight3.normalBias);
        }else if (i == 4){
            lresult = CalcPointLight(pointLight4, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight4.position, depthCubeMap4, pointLight4.farPlane, pointLight4.bias, pointLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 3: spot light
    for(int i = 0; i < spotLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcSpotLight(spotLight0, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight0.lightSpaceMatrix, spotLight0.position, spotLight0.shadowMap, spotLight0.bias, spotLight0.normalBias);
        } else if (i == 1){
            lresult = CalcSpotLight(spotLight1, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight1.lightSpaceMatrix, spotLight1.position, spotLight1.shadowMap, spotLight1.bias, spotLight1.normalBias);
        } else if (i == 2){
            lresult = CalcSpotLight(spotLight2, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight2.lightSpaceMatrix, spotLight2.position, spotLight2.shadowMap, spotLight2.bias, spotLight2.normalBias);
        } else if (i == 3){
            lresult = CalcSpotLight(spotLight3, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight3.lightSpaceMatrix, spotLight3.position, spotLight3.shadowMap, spotLight3.bias, spotLight3.normalBias);
        } else if (i == 4){
            lresult = CalcSpotLight(spotLight4, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight4.lightSpaceMatrix, spotLight4.position, spotLight4.shadowMap, spotLight4.bias, spotLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }

    FragColor = ambient + vec4(result, 0.0);
    if (textureApplyMode == 1){
        // textureApplyMode == 1 is DECAL
        vec4 coltex = texture(texture0, TexCoords.st);
        vec3 col = FragColor.rgb * (1.0-coltex.a) + coltex.rgb * coltex.a;
        FragColor = vec4(col, FragColor.a);
    }
}

// calculates the color when using a directional light.
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading (Phong)
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    // specular shading (Blinn-Phong)
    // vec3 halfwayDir = normalize(lightDir + viewDir);
    // float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);

    // combine results
    vec3 diffuse = light.diffuse * (diff * (vec3(texture(texture0, TexCoords)) * material.diffuse));
    vec3 specular = light.specular * (spec * (vec3(texture(texture0, TexCoords)) * material.specular));
    return (diffuse + specular);
}

// calculates the color when using a point light.
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // combine results
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation;
    specular *= attenuation;
    return (diffuse + specular);
}

// calculates the color when using a spot light.
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);

    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results

    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;

    return (diffuse + specular);
}

float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias)
{
    vec4 fragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0);

    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    // check whether current frag pos is in shadow
    // PCF
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias)
{

    // get vector between fragment position and light position
    vec3 fragToLight = FragPos - lightPos;
    float currentDepth = length(fragToLight);

    float shadow = 0.0;

    // Bias calc
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    int samples = 20;
    float viewDistance = length(viewPos - FragPos);
    float diskRadius = (1.0 + (viewDistance / farPlane)) / 500.0;

    for(int i = 0; i < samples; i++)
    {
        float closestDepth = texture(cubeMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= farPlane;   // undo mapping [0;1]
        if((currentDepth - bias) > closestDepth){
            shadow += 1.0;
        }
    }
    shadow /= float(samples);
    return shadow;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:108: '(' : syntax error: Array size must appear after variable name\n"
This renderer requires atleast OpenGL 3.2. The version available is: 2.1 ATI-3.5.5
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoords = aTexCoords;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:108: '(' : syntax error: Array size must appear after variable name

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

struct Material {
    vec4 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct DirLight {
    vec3 position; // specifically for shadows
    vec3 direction;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float farPlane;
    float bias;
    float normalBias;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

uniform sampler2D texture0;
uniform int textureApplyMode;

uniform vec3 sceneAmbient;
uniform vec3 viewPos;

// Some graphics cards appear not to support arrays. One way around this is to explicitly roll out the array.
#define MAX_LIGHTS 5
uniform DirLight dirLight0;
uniform DirLight dirLight1;
uniform DirLight dirLight2;
uniform DirLight dirLight3;
uniform DirLight dirLight4;

uniform PointLight pointLight0;
uniform PointLight pointLight1;
uniform PointLight pointLight2;
uniform PointLight pointLight3;
uniform PointLight pointLight4;

uniform SpotLight spotLight0;
uniform SpotLight spotLight1;
uniform SpotLight spotLight2;
uniform SpotLight spotLight3;
uniform SpotLight spotLight4;

// For some reason, we are not allowed to store samplerCube in structs or arrays
// So allow a max of 5
uniform samplerCube depthCubeMap0;
uniform samplerCube depthCubeMap1;
uniform samplerCube depthCubeMap2;
uniform samplerCube depthCubeMap3;
uniform samplerCube depthCubeMap4;

uniform int dirLightLen;
uniform int pointLightLen;
uniform int spotLightLen;

uniform Material material;

// array of offset direction for sampling in pointlight shadows
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1),
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

// function prototypes
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias);
float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias);

void main()
{
    // Lighting properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // Give it some intial ambient light
    vec4 ambient = texture(texture0, TexCoords);

    // textureApplyMode 1 (GL_DECAL) gets applied later.
    if (textureApplyMode == 2)  // ADD
        ambient = (ambient + material.ambient, 1.0) * vec4(sceneAmbient, 1.0);
    else if (textureApplyMode == 1)
        ambient = material.ambient;
    else if (textureApplyMode != 1)
        // In this case, we either have no texture, or we want to use GL_BLEND.
        ambient *= material.ambient * vec4(sceneAmbient, 1.0);

    vec3 result = vec3(0.0);
    // phase 1: directional lighting
    for(int i = 0; i < dirLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcDirLight(dirLight0, norm, viewDir);
            shadow = ShadowCalculation(dirLight0.lightSpaceMatrix, dirLight0.position, dirLight0.shadowMap, dirLight0.bias, dirLight0.normalBias);
        } else if (i == 1){
            lresult = CalcDirLight(dirLight1, norm, viewDir);
            shadow = ShadowCalculation(dirLight1.lightSpaceMatrix, dirLight1.position, dirLight1.shadowMap, dirLight1.bias, dirLight1.normalBias);
        } else if (i == 2){
            lresult = CalcDirLight(dirLight2, norm, viewDir);
            shadow = ShadowCalculation(dirLight2.lightSpaceMatrix, dirLight2.position, dirLight2.shadowMap, dirLight2.bias, dirLight2.normalBias);
        } else if (i == 3){
            lresult = CalcDirLight(dirLight3, norm, viewDir);
            shadow = ShadowCalculation(dirLight3.lightSpaceMatrix, dirLight3.position, dirLight3.shadowMap, dirLight3.bias, dirLight3.normalBias);
        } else if (i == 4){
            lresult = CalcDirLight(dirLight4, norm, viewDir);
            shadow = ShadowCalculation(dirLight4.lightSpaceMatrix, dirLight4.position, dirLight4.shadowMap, dirLight4.bias, dirLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 2: point lights
    for(int i = 0; i < pointLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;

        if (i == 0){
            lresult = CalcPointLight(pointLight0, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight0.position, depthCubeMap0, pointLight0.farPlane, pointLight0.bias, pointLight0.normalBias);
        }else if (i == 1){
            lresult = CalcPointLight(pointLight1, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight1.position, depthCubeMap1, pointLight1.farPlane, pointLight1.bias, pointLight1.normalBias);
        }else if (i == 2){
            lresult = CalcPointLight(pointLight2, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight2.position, depthCubeMap2, pointLight2.farPlane, pointLight2.bias, pointLight2.normalBias);
        }else if (i == 3){
            lresult = CalcPointLight(pointLight3, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight3.position, depthCubeMap3, pointLight3.farPlane, pointLight3.bias, pointLight3.normalBias);
        }else if (i == 4){
            lresult = CalcPointLight(pointLight4, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight4.position, depthCubeMap4, pointLight4.farPlane, pointLight4.bias, pointLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 3: spot light
    for(int i = 0; i < spotLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcSpotLight(spotLight0, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight0.lightSpaceMatrix, spotLight0.position, spotLight0.shadowMap, spotLight0.bias, spotLight0.normalBias);
        } else if (i == 1){
            lresult = CalcSpotLight(spotLight1, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight1.lightSpaceMatrix, spotLight1.position, spotLight1.shadowMap, spotLight1.bias, spotLight1.normalBias);
        } else if (i == 2){
            lresult = CalcSpotLight(spotLight2, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight2.lightSpaceMatrix, spotLight2.position, spotLight2.shadowMap, spotLight2.bias, spotLight2.normalBias);
        } else if (i == 3){
            lresult = CalcSpotLight(spotLight3, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight3.lightSpaceMatrix, spotLight3.position, spotLight3.shadowMap, spotLight3.bias, spotLight3.normalBias);
        } else if (i == 4){
            lresult = CalcSpotLight(spotLight4, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight4.lightSpaceMatrix, spotLight4.position, spotLight4.shadowMap, spotLight4.bias, spotLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }

    FragColor = ambient + vec4(result, 0.0);
    if (textureApplyMode == 1){
        // textureApplyMode == 1 is DECAL
        vec4 coltex = texture(texture0, TexCoords.st);
        vec3 col = FragColor.rgb * (1.0-coltex.a) + coltex.rgb * coltex.a;
        FragColor = vec4(col, FragColor.a);
    }
}

// calculates the color when using a directional light.
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading (Phong)
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    // specular shading (Blinn-Phong)
    // vec3 halfwayDir = normalize(lightDir + viewDir);
    // float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);

    // combine results
    vec3 diffuse = light.diffuse * (diff * (vec3(texture(texture0, TexCoords)) * material.diffuse));
    vec3 specular = light.specular * (spec * (vec3(texture(texture0, TexCoords)) * material.specular));
    return (diffuse + specular);
}

// calculates the color when using a point light.
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // combine results
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation;
    specular *= attenuation;
    return (diffuse + specular);
}

// calculates the color when using a spot light.
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);

    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results

    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;

    return (diffuse + specular);
}

float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias)
{
    vec4 fragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0);

    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    // check whether current frag pos is in shadow
    // PCF
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias)
{

    // get vector between fragment position and light position
    vec3 fragToLight = FragPos - lightPos;
    float currentDepth = length(fragToLight);

    float shadow = 0.0;

    // Bias calc
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    int samples = 20;
    float viewDistance = length(viewPos - FragPos);
    float diskRadius = (1.0 + (viewDistance / farPlane)) / 500.0;

    for(int i = 0; i < samples; i++)
    {
        float closestDepth = texture(cubeMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= farPlane;   // undo mapping [0;1]
        if((currentDepth - bias) > closestDepth){
            shadow += 1.0;
        }
    }
    shadow /= float(samples);
    return shadow;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:108: '(' : syntax error: Array size must appear after variable name\n"
Actor(
  (backbones): Backbones(
    (hidden): ModuleList(
      (0): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (1): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (2): Sequential(
        (0): Linear(in_features=3, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
    )
    (cnn_tail): ModuleList()
  )
  (fc_body): Sequential(
    (0): Linear(in_features=96, out_features=128, bias=True)
    (1): LeakyReLU(negative_slope=0.01, inplace=True)
    (2): Linear(in_features=128, out_features=128, bias=True)
    (3): LeakyReLU(negative_slope=0.01, inplace=True)
    (4): Linear(in_features=128, out_features=8, bias=True)
    (5): Tanh()
  )
)
Critic(
  (backbones): Backbones(
    (hidden): ModuleList(
      (0): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (1): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (2): Sequential(
        (0): Linear(in_features=3, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
    )
    (cnn_tail): ModuleList()
  )
  (fc_body): Sequential(
    (0): Linear(in_features=96, out_features=128, bias=True)
    (1): LeakyReLU(negative_slope=0.01, inplace=True)
  )
  (critic_body): Sequential(
    (0): Linear(in_features=136, out_features=64, bias=True)
    (1): LeakyReLU(negative_slope=0.01, inplace=True)
    (2): Linear(in_features=64, out_features=1, bias=True)
  )
)
Episode 1	Exploration: 0.799000	Average Score: -0.70	Current Score: -0.70	Actor Loss: 0.00e+00	Critic Loss: 0.00e+00
Episode 2	Exploration: 0.798000	Average Score: -0.76	Current Score: -0.81	Actor Loss: 0.00e+00	Critic Loss: 0.00e+00
Episode 3	Exploration: 0.797000	Average Score: -0.67	Current Score: -0.51	Actor Loss: 7.00e-01	Critic Loss: 2.85e-02
Episode 4	Exploration: 0.796000	Average Score: -0.67	Current Score: -0.67	Actor Loss: 5.81e-01	Critic Loss: 7.37e-03
Episode 5	Exploration: 0.795000	Average Score: -0.63	Current Score: -0.46	Actor Loss: 5.38e-01	Critic Loss: 4.96e-03
Episode 6	Exploration: 0.794000	Average Score: -0.67	Current Score: -0.88	Actor Loss: 6.33e-01	Critic Loss: 4.17e-03
Episode 7	Exploration: 0.793000	Average Score: -0.70	Current Score: -0.87	Actor Loss: 6.82e-01	Critic Loss: 6.28e-03
Episode 8	Exploration: 0.792000	Average Score: -0.70	Current Score: -0.72	Actor Loss: 7.48e-01	Critic Loss: 7.96e-03
Episode 9	Exploration: 0.791000	Average Score: -0.69	Current Score: -0.60	Actor Loss: 7.80e-01	Critic Loss: 7.20e-03
Episode 10	Exploration: 0.790000	Average Score: -0.70	Current Score: -0.79	Actor Loss: 6.25e-01	Critic Loss: 2.88e-03
Episode 11	Exploration: 0.789000	Average Score: -0.69	Current Score: -0.53	Actor Loss: 6.80e-01	Critic Loss: 3.65e-03
Episode 12	Exploration: 0.788000	Average Score: -0.66	Current Score: -0.35	Actor Loss: 6.19e-01	Critic Loss: 3.74e-03
Episode 13	Exploration: 0.787000	Average Score: -0.66	Current Score: -0.67	Actor Loss: 6.81e-01	Critic Loss: 3.03e-03
Episode 14	Exploration: 0.786000	Average Score: -0.64	Current Score: -0.42	Actor Loss: 6.93e-01	Critic Loss: 2.22e-03
Episode 15	Exploration: 0.785000	Average Score: -0.64	Current Score: -0.63	Actor Loss: 6.99e-01	Critic Loss: 3.37e-03
Episode 16	Exploration: 0.784000	Average Score: -0.63	Current Score: -0.54	Actor Loss: 7.28e-01	Critic Loss: 2.18e-03
Episode 17	Exploration: 0.783000	Average Score: -0.63	Current Score: -0.59	Actor Loss: 7.32e-01	Critic Loss: 2.12e-03
Episode 18	Exploration: 0.782000	Average Score: -0.62	Current Score: -0.44	Actor Loss: 7.23e-01	Critic Loss: 2.07e-03
Episode 19	Exploration: 0.781000	Average Score: -0.63	Current Score: -0.81	Actor Loss: 7.33e-01	Critic Loss: 2.19e-03
Episode 20	Exploration: 0.780000	Average Score: -0.63	Current Score: -0.60	Actor Loss: 8.04e-01	Critic Loss: 2.23e-03
Episode 21	Exploration: 0.779000	Average Score: -0.63	Current Score: -0.59	Actor Loss: 8.22e-01	Critic Loss: 1.05e-03
Episode 22	Exploration: 0.778000	Average Score: -0.62	Current Score: -0.37	Actor Loss: 8.07e-01	Critic Loss: 1.73e-03
Episode 23	Exploration: 0.777000	Average Score: -0.60	Current Score: -0.31	Actor Loss: 8.27e-01	Critic Loss: 2.12e-03
Episode 24	Exploration: 0.776000	Average Score: -0.59	Current Score: -0.28	Actor Loss: 8.10e-01	Critic Loss: 3.80e-03
Episode 25	Exploration: 0.775000	Average Score: -0.58	Current Score: -0.43	Actor Loss: 8.08e-01	Critic Loss: 1.80e-03
Episode 26	Exploration: 0.774000	Average Score: -0.58	Current Score: -0.64	Actor Loss: 8.35e-01	Critic Loss: 1.93e-03
Episode 27	Exploration: 0.773000	Average Score: -0.58	Current Score: -0.39	Actor Loss: 8.54e-01	Critic Loss: 1.41e-03
Episode 28	Exploration: 0.772000	Average Score: -0.57	Current Score: -0.34	Actor Loss: 8.75e-01	Critic Loss: 1.01e-03
Episode 29	Exploration: 0.771000	Average Score: -0.56	Current Score: -0.33	Actor Loss: 8.92e-01	Critic Loss: 1.42e-03
Episode 30	Exploration: 0.770000	Average Score: -0.55	Current Score: -0.27	Actor Loss: 8.93e-01	Critic Loss: 3.78e-03
Episode 31	Exploration: 0.769000	Average Score: -0.54	Current Score: -0.31	Actor Loss: 8.42e-01	Critic Loss: 2.28e-03
Episode 32	Exploration: 0.768000	Average Score: -0.55	Current Score: -0.85	Actor Loss: 8.81e-01	Critic Loss: 1.48e-03
Episode 33	Exploration: 0.767000	Average Score: -0.55	Current Score: -0.32	Actor Loss: 9.08e-01	Critic Loss: 2.26e-03
Episode 34	Exploration: 0.766000	Average Score: -0.55	Current Score: -0.63	Actor Loss: 9.65e-01	Critic Loss: 3.08e-03
Episode 35	Exploration: 0.765000	Average Score: -0.54	Current Score: -0.41	Actor Loss: 9.45e-01	Critic Loss: 2.34e-03
Episode 36	Exploration: 0.764000	Average Score: -0.55	Current Score: -0.75	Actor Loss: 9.76e-01	Critic Loss: 1.84e-03
Episode 37	Exploration: 0.763000	Average Score: -0.55	Current Score: -0.56	Actor Loss: 9.76e-01	Critic Loss: 1.46e-03
Episode 38	Exploration: 0.762000	Average Score: -0.55	Current Score: -0.61	Actor Loss: 1.06e+00	Critic Loss: 1.94e-03
Episode 39	Exploration: 0.761000	Average Score: -0.55	Current Score: -0.48	Actor Loss: 1.03e+00	Critic Loss: 1.91e-03
Episode 40	Exploration: 0.760000	Average Score: -0.55	Current Score: -0.40	Actor Loss: 1.04e+00	Critic Loss: 1.51e-03
Episode 41	Exploration: 0.759000	Average Score: -0.54	Current Score: -0.43	Actor Loss: 1.06e+00	Critic Loss: 1.01e-03
Episode 42	Exploration: 0.758000	Average Score: -0.54	Current Score: -0.56	Actor Loss: 1.11e+00	Critic Loss: 1.85e-03
Episode 43	Exploration: 0.757000	Average Score: -0.54	Current Score: -0.50	Actor Loss: 1.10e+00	Critic Loss: 1.10e-03
Episode 44	Exploration: 0.756000	Average Score: -0.54	Current Score: -0.33	Actor Loss: 1.11e+00	Critic Loss: 1.40e-03
Episode 45	Exploration: 0.755000	Average Score: -0.54	Current Score: -0.43	Actor Loss: 1.09e+00	Critic Loss: 1.62e-03
Episode 46	Exploration: 0.754000	Average Score: -0.53	Current Score: -0.26	Actor Loss: 1.15e+00	Critic Loss: 1.17e-03
Episode 47	Exploration: 0.753000	Average Score: -0.53	Current Score: -0.32	Actor Loss: 1.14e+00	Critic Loss: 2.28e-03
Episode 48	Exploration: 0.752000	Average Score: -0.52	Current Score: -0.20	Actor Loss: 1.12e+00	Critic Loss: 1.17e-03
Episode 49	Exploration: 0.751000	Average Score: -0.52	Current Score: -0.58	Actor Loss: 1.13e+00	Critic Loss: 1.64e-03
/home/zhenwang/code/git/robotics/PyRep/pyrep/pyrep.py:209: UserWarning: Could not change simulation timestep. You may need to change it to "custom dt" using simulation settings dialog.
  warnings.warn('Could not change simulation timestep. You may need '
/home/zhenwang/software/anaconda3/envs/robotics/lib/python3.7/site-packages/gym/logger.py:30: UserWarning: [33mWARN: Box bound precision lowered by casting to float32[0m
  warnings.warn(colorize('%s: %s'%('WARN', msg % args), 'yellow'))
Episode 50	Exploration: 0.750000	Average Score: -0.52	Current Score: -0.34	Actor Loss: 1.18e+00	Critic Loss: 4.05e-03
Save Model
Episode 50	Average Score: -0.52
Done
QObject::~QObject: Timers cannot be stopped from another thread
lib: 1
lic: 1

CoppeliaSim Edu V4.0.0. (rev. 4)
Using the default Lua library.
Loaded the video compression library.
Add-on script 'simAddOnScript-addOnScriptDemo.lua' was loaded.
Add-on script 'simAddOnScript-b0RemoteApiServer.lua' was loaded.
Add-on script 'simAddOnScript_PyRep.lua' was loaded.
If CoppeliaSim crashes now, try to install libgl1-mesa-dev on your system:
>sudo apt install libgl1-mesa-dev
OpenGL: Parallels and ATI Technologies Inc., Renderer: Parallels using AMD Radeon Pro 560X OpenGL Engine, Version: 2.1 ATI-3.5.5
...did not crash.
Simulator launched.
Plugin 'Geometric': loading...
Plugin 'Geometric': load succeeded.
Plugin 'Assimp': loading...
Plugin 'Assimp': warning: replaced variable 'simAssimp'
Plugin 'Assimp': load succeeded.
Plugin 'BlueZero': loading...
Plugin 'BlueZero': warning: replaced variable 'simB0'
Plugin 'BlueZero': load succeeded.
Plugin 'BubbleRob': loading...
Plugin 'BubbleRob': load succeeded.
Plugin 'Bwf': loading...
Plugin 'Bwf': load succeeded.
Plugin 'CodeEditor': loading...
Plugin 'CodeEditor': load succeeded.
Plugin 'Collada': loading...
Plugin 'Collada': load succeeded.
Plugin 'ConvexDecompose': loading...
Plugin 'ConvexDecompose': load succeeded.
Plugin 'CustomUI': loading...
Plugin 'CustomUI': warning: replaced variable 'simUI'
Plugin 'CustomUI': warning: replaced function 'simUI.insertTableRow@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.removeTableRow@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.insertTableColumn@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.removeTableColumn@CustomUI'
Plugin 'CustomUI': warning: replaced function 'simUI.setScene3DNodeParam@CustomUI'
Plugin 'CustomUI': load succeeded.
Plugin 'DynamicsBullet-2-78': loading...
Plugin 'DynamicsBullet-2-78': load succeeded.
Plugin 'DynamicsBullet-2-83': loading...
Plugin 'DynamicsBullet-2-83': load succeeded.
Plugin 'DynamicsNewton': loading...
Plugin 'DynamicsNewton': load succeeded.
Plugin 'DynamicsOde': loading...
Plugin 'DynamicsOde': load succeeded.
Plugin 'DynamicsVortex': loading...
Plugin 'DynamicsVortex': load succeeded.
Plugin 'ExternalRenderer': loading...
Plugin 'ExternalRenderer': load succeeded.
Plugin 'ICP': loading...
Plugin 'ICP': warning: replaced variable 'simICP'
Plugin 'ICP': load succeeded.
Plugin 'Image': loading...
Plugin 'Image': warning: replaced variable 'simIM'
Plugin 'Image': load succeeded.
Plugin 'K3': loading...
Plugin 'K3': load succeeded.
Plugin 'Lic': loading...
Plugin 'Lic': load succeeded.
Plugin 'LuaCommander': loading...
Plugin 'LuaCommander': warning: replaced variable 'simLuaCmd'
Plugin 'LuaCommander': load succeeded.
Plugin 'LuaRemoteApiClient': loading...
Plugin 'LuaRemoteApiClient': load succeeded.
Plugin 'Mtb': loading...
Plugin 'Mtb': load succeeded.
Plugin 'OMPL': loading...
Plugin 'OMPL': warning: replaced variable 'simOMPL'
Plugin 'OMPL': load succeeded.
Plugin 'OpenGL3Renderer': loading...
Plugin 'OpenGL3Renderer': load succeeded.
Plugin 'OpenMesh': loading...
Plugin 'OpenMesh': load succeeded.
Plugin 'Qhull': loading...
Plugin 'Qhull': load succeeded.
Plugin 'RRS1': loading...
Plugin 'RRS1': load succeeded.
Plugin 'ReflexxesTypeII': loading...
Plugin 'ReflexxesTypeII': load succeeded.
Plugin 'RemoteApi': loading...
Starting a remote API server on port 19997
Plugin 'RemoteApi': load succeeded.
Plugin 'SDF': loading...
Plugin 'SDF': warning: replaced variable 'simSDF'
Plugin 'SDF': load succeeded.
Plugin 'SurfaceReconstruction': loading...
Plugin 'SurfaceReconstruction': warning: replaced variable 'simSurfRec'
Plugin 'SurfaceReconstruction': load succeeded.
Plugin 'Urdf': loading...
Plugin 'Urdf': load succeeded.
Plugin 'Vision': loading...
Plugin 'Vision': load succeeded.
Using the 'Geometric' plugin.
Initializing the Bullet physics engine in plugin 'DynamicsBullet_2_83'...
Engine version: 2.83.7
Plugin version: 11
Initialization successful.
This renderer requires atleast OpenGL 3.2. The version available is: 2.1 ATI-3.5.5
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoords = aTexCoords;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:108: '(' : syntax error: Array size must appear after variable name

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

struct Material {
    vec4 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct DirLight {
    vec3 position; // specifically for shadows
    vec3 direction;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float farPlane;
    float bias;
    float normalBias;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

uniform sampler2D texture0;
uniform int textureApplyMode;

uniform vec3 sceneAmbient;
uniform vec3 viewPos;

// Some graphics cards appear not to support arrays. One way around this is to explicitly roll out the array.
#define MAX_LIGHTS 5
uniform DirLight dirLight0;
uniform DirLight dirLight1;
uniform DirLight dirLight2;
uniform DirLight dirLight3;
uniform DirLight dirLight4;

uniform PointLight pointLight0;
uniform PointLight pointLight1;
uniform PointLight pointLight2;
uniform PointLight pointLight3;
uniform PointLight pointLight4;

uniform SpotLight spotLight0;
uniform SpotLight spotLight1;
uniform SpotLight spotLight2;
uniform SpotLight spotLight3;
uniform SpotLight spotLight4;

// For some reason, we are not allowed to store samplerCube in structs or arrays
// So allow a max of 5
uniform samplerCube depthCubeMap0;
uniform samplerCube depthCubeMap1;
uniform samplerCube depthCubeMap2;
uniform samplerCube depthCubeMap3;
uniform samplerCube depthCubeMap4;

uniform int dirLightLen;
uniform int pointLightLen;
uniform int spotLightLen;

uniform Material material;

// array of offset direction for sampling in pointlight shadows
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1),
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

// function prototypes
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias);
float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias);

void main()
{
    // Lighting properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // Give it some intial ambient light
    vec4 ambient = texture(texture0, TexCoords);

    // textureApplyMode 1 (GL_DECAL) gets applied later.
    if (textureApplyMode == 2)  // ADD
        ambient = (ambient + material.ambient, 1.0) * vec4(sceneAmbient, 1.0);
    else if (textureApplyMode == 1)
        ambient = material.ambient;
    else if (textureApplyMode != 1)
        // In this case, we either have no texture, or we want to use GL_BLEND.
        ambient *= material.ambient * vec4(sceneAmbient, 1.0);

    vec3 result = vec3(0.0);
    // phase 1: directional lighting
    for(int i = 0; i < dirLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcDirLight(dirLight0, norm, viewDir);
            shadow = ShadowCalculation(dirLight0.lightSpaceMatrix, dirLight0.position, dirLight0.shadowMap, dirLight0.bias, dirLight0.normalBias);
        } else if (i == 1){
            lresult = CalcDirLight(dirLight1, norm, viewDir);
            shadow = ShadowCalculation(dirLight1.lightSpaceMatrix, dirLight1.position, dirLight1.shadowMap, dirLight1.bias, dirLight1.normalBias);
        } else if (i == 2){
            lresult = CalcDirLight(dirLight2, norm, viewDir);
            shadow = ShadowCalculation(dirLight2.lightSpaceMatrix, dirLight2.position, dirLight2.shadowMap, dirLight2.bias, dirLight2.normalBias);
        } else if (i == 3){
            lresult = CalcDirLight(dirLight3, norm, viewDir);
            shadow = ShadowCalculation(dirLight3.lightSpaceMatrix, dirLight3.position, dirLight3.shadowMap, dirLight3.bias, dirLight3.normalBias);
        } else if (i == 4){
            lresult = CalcDirLight(dirLight4, norm, viewDir);
            shadow = ShadowCalculation(dirLight4.lightSpaceMatrix, dirLight4.position, dirLight4.shadowMap, dirLight4.bias, dirLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 2: point lights
    for(int i = 0; i < pointLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;

        if (i == 0){
            lresult = CalcPointLight(pointLight0, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight0.position, depthCubeMap0, pointLight0.farPlane, pointLight0.bias, pointLight0.normalBias);
        }else if (i == 1){
            lresult = CalcPointLight(pointLight1, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight1.position, depthCubeMap1, pointLight1.farPlane, pointLight1.bias, pointLight1.normalBias);
        }else if (i == 2){
            lresult = CalcPointLight(pointLight2, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight2.position, depthCubeMap2, pointLight2.farPlane, pointLight2.bias, pointLight2.normalBias);
        }else if (i == 3){
            lresult = CalcPointLight(pointLight3, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight3.position, depthCubeMap3, pointLight3.farPlane, pointLight3.bias, pointLight3.normalBias);
        }else if (i == 4){
            lresult = CalcPointLight(pointLight4, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight4.position, depthCubeMap4, pointLight4.farPlane, pointLight4.bias, pointLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 3: spot light
    for(int i = 0; i < spotLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcSpotLight(spotLight0, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight0.lightSpaceMatrix, spotLight0.position, spotLight0.shadowMap, spotLight0.bias, spotLight0.normalBias);
        } else if (i == 1){
            lresult = CalcSpotLight(spotLight1, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight1.lightSpaceMatrix, spotLight1.position, spotLight1.shadowMap, spotLight1.bias, spotLight1.normalBias);
        } else if (i == 2){
            lresult = CalcSpotLight(spotLight2, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight2.lightSpaceMatrix, spotLight2.position, spotLight2.shadowMap, spotLight2.bias, spotLight2.normalBias);
        } else if (i == 3){
            lresult = CalcSpotLight(spotLight3, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight3.lightSpaceMatrix, spotLight3.position, spotLight3.shadowMap, spotLight3.bias, spotLight3.normalBias);
        } else if (i == 4){
            lresult = CalcSpotLight(spotLight4, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight4.lightSpaceMatrix, spotLight4.position, spotLight4.shadowMap, spotLight4.bias, spotLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }

    FragColor = ambient + vec4(result, 0.0);
    if (textureApplyMode == 1){
        // textureApplyMode == 1 is DECAL
        vec4 coltex = texture(texture0, TexCoords.st);
        vec3 col = FragColor.rgb * (1.0-coltex.a) + coltex.rgb * coltex.a;
        FragColor = vec4(col, FragColor.a);
    }
}

// calculates the color when using a directional light.
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading (Phong)
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    // specular shading (Blinn-Phong)
    // vec3 halfwayDir = normalize(lightDir + viewDir);
    // float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);

    // combine results
    vec3 diffuse = light.diffuse * (diff * (vec3(texture(texture0, TexCoords)) * material.diffuse));
    vec3 specular = light.specular * (spec * (vec3(texture(texture0, TexCoords)) * material.specular));
    return (diffuse + specular);
}

// calculates the color when using a point light.
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // combine results
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation;
    specular *= attenuation;
    return (diffuse + specular);
}

// calculates the color when using a spot light.
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);

    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results

    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;

    return (diffuse + specular);
}

float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias)
{
    vec4 fragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0);

    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    // check whether current frag pos is in shadow
    // PCF
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias)
{

    // get vector between fragment position and light position
    vec3 fragToLight = FragPos - lightPos;
    float currentDepth = length(fragToLight);

    float shadow = 0.0;

    // Bias calc
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    int samples = 20;
    float viewDistance = length(viewPos - FragPos);
    float diskRadius = (1.0 + (viewDistance / farPlane)) / 500.0;

    for(int i = 0; i < samples; i++)
    {
        float closestDepth = texture(cubeMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= farPlane;   // undo mapping [0;1]
        if((currentDepth - bias) > closestDepth){
            shadow += 1.0;
        }
    }
    shadow /= float(samples);
    return shadow;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:108: '(' : syntax error: Array size must appear after variable name\n"
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

uniform mat4 lightSpaceMatrix;
uniform mat4 model;

void main()
{
    gl_Position = lightSpaceMatrix * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

void main(void)
{
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\n"
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;

uniform mat4 model;

out vec3 FragPos;

uniform mat4 lightSpaceMatrix;

void main()
{
    gl_Position = lightSpaceMatrix * model * vec4(aPos, 1.0);
    FragPos = vec3(model * vec4(aPos, 1.0));
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1
in vec3 FragPos;

uniform vec3 lightPos;
uniform float far_plane;

void main()
{
    float lightDistance = length(FragPos - lightPos);

    // map to [0;1] range by dividing by far_plane
    lightDistance = lightDistance / far_plane;

    gl_FragDepth = lightDistance;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\n"
This renderer requires atleast OpenGL 3.2. The version available is: 2.1 ATI-3.5.5
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoords = aTexCoords;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:108: '(' : syntax error: Array size must appear after variable name

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

struct Material {
    vec4 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct DirLight {
    vec3 position; // specifically for shadows
    vec3 direction;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float farPlane;
    float bias;
    float normalBias;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

uniform sampler2D texture0;
uniform int textureApplyMode;

uniform vec3 sceneAmbient;
uniform vec3 viewPos;

// Some graphics cards appear not to support arrays. One way around this is to explicitly roll out the array.
#define MAX_LIGHTS 5
uniform DirLight dirLight0;
uniform DirLight dirLight1;
uniform DirLight dirLight2;
uniform DirLight dirLight3;
uniform DirLight dirLight4;

uniform PointLight pointLight0;
uniform PointLight pointLight1;
uniform PointLight pointLight2;
uniform PointLight pointLight3;
uniform PointLight pointLight4;

uniform SpotLight spotLight0;
uniform SpotLight spotLight1;
uniform SpotLight spotLight2;
uniform SpotLight spotLight3;
uniform SpotLight spotLight4;

// For some reason, we are not allowed to store samplerCube in structs or arrays
// So allow a max of 5
uniform samplerCube depthCubeMap0;
uniform samplerCube depthCubeMap1;
uniform samplerCube depthCubeMap2;
uniform samplerCube depthCubeMap3;
uniform samplerCube depthCubeMap4;

uniform int dirLightLen;
uniform int pointLightLen;
uniform int spotLightLen;

uniform Material material;

// array of offset direction for sampling in pointlight shadows
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1),
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

// function prototypes
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias);
float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias);

void main()
{
    // Lighting properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // Give it some intial ambient light
    vec4 ambient = texture(texture0, TexCoords);

    // textureApplyMode 1 (GL_DECAL) gets applied later.
    if (textureApplyMode == 2)  // ADD
        ambient = (ambient + material.ambient, 1.0) * vec4(sceneAmbient, 1.0);
    else if (textureApplyMode == 1)
        ambient = material.ambient;
    else if (textureApplyMode != 1)
        // In this case, we either have no texture, or we want to use GL_BLEND.
        ambient *= material.ambient * vec4(sceneAmbient, 1.0);

    vec3 result = vec3(0.0);
    // phase 1: directional lighting
    for(int i = 0; i < dirLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcDirLight(dirLight0, norm, viewDir);
            shadow = ShadowCalculation(dirLight0.lightSpaceMatrix, dirLight0.position, dirLight0.shadowMap, dirLight0.bias, dirLight0.normalBias);
        } else if (i == 1){
            lresult = CalcDirLight(dirLight1, norm, viewDir);
            shadow = ShadowCalculation(dirLight1.lightSpaceMatrix, dirLight1.position, dirLight1.shadowMap, dirLight1.bias, dirLight1.normalBias);
        } else if (i == 2){
            lresult = CalcDirLight(dirLight2, norm, viewDir);
            shadow = ShadowCalculation(dirLight2.lightSpaceMatrix, dirLight2.position, dirLight2.shadowMap, dirLight2.bias, dirLight2.normalBias);
        } else if (i == 3){
            lresult = CalcDirLight(dirLight3, norm, viewDir);
            shadow = ShadowCalculation(dirLight3.lightSpaceMatrix, dirLight3.position, dirLight3.shadowMap, dirLight3.bias, dirLight3.normalBias);
        } else if (i == 4){
            lresult = CalcDirLight(dirLight4, norm, viewDir);
            shadow = ShadowCalculation(dirLight4.lightSpaceMatrix, dirLight4.position, dirLight4.shadowMap, dirLight4.bias, dirLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 2: point lights
    for(int i = 0; i < pointLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;

        if (i == 0){
            lresult = CalcPointLight(pointLight0, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight0.position, depthCubeMap0, pointLight0.farPlane, pointLight0.bias, pointLight0.normalBias);
        }else if (i == 1){
            lresult = CalcPointLight(pointLight1, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight1.position, depthCubeMap1, pointLight1.farPlane, pointLight1.bias, pointLight1.normalBias);
        }else if (i == 2){
            lresult = CalcPointLight(pointLight2, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight2.position, depthCubeMap2, pointLight2.farPlane, pointLight2.bias, pointLight2.normalBias);
        }else if (i == 3){
            lresult = CalcPointLight(pointLight3, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight3.position, depthCubeMap3, pointLight3.farPlane, pointLight3.bias, pointLight3.normalBias);
        }else if (i == 4){
            lresult = CalcPointLight(pointLight4, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight4.position, depthCubeMap4, pointLight4.farPlane, pointLight4.bias, pointLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 3: spot light
    for(int i = 0; i < spotLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcSpotLight(spotLight0, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight0.lightSpaceMatrix, spotLight0.position, spotLight0.shadowMap, spotLight0.bias, spotLight0.normalBias);
        } else if (i == 1){
            lresult = CalcSpotLight(spotLight1, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight1.lightSpaceMatrix, spotLight1.position, spotLight1.shadowMap, spotLight1.bias, spotLight1.normalBias);
        } else if (i == 2){
            lresult = CalcSpotLight(spotLight2, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight2.lightSpaceMatrix, spotLight2.position, spotLight2.shadowMap, spotLight2.bias, spotLight2.normalBias);
        } else if (i == 3){
            lresult = CalcSpotLight(spotLight3, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight3.lightSpaceMatrix, spotLight3.position, spotLight3.shadowMap, spotLight3.bias, spotLight3.normalBias);
        } else if (i == 4){
            lresult = CalcSpotLight(spotLight4, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight4.lightSpaceMatrix, spotLight4.position, spotLight4.shadowMap, spotLight4.bias, spotLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }

    FragColor = ambient + vec4(result, 0.0);
    if (textureApplyMode == 1){
        // textureApplyMode == 1 is DECAL
        vec4 coltex = texture(texture0, TexCoords.st);
        vec3 col = FragColor.rgb * (1.0-coltex.a) + coltex.rgb * coltex.a;
        FragColor = vec4(col, FragColor.a);
    }
}

// calculates the color when using a directional light.
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading (Phong)
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    // specular shading (Blinn-Phong)
    // vec3 halfwayDir = normalize(lightDir + viewDir);
    // float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);

    // combine results
    vec3 diffuse = light.diffuse * (diff * (vec3(texture(texture0, TexCoords)) * material.diffuse));
    vec3 specular = light.specular * (spec * (vec3(texture(texture0, TexCoords)) * material.specular));
    return (diffuse + specular);
}

// calculates the color when using a point light.
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // combine results
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation;
    specular *= attenuation;
    return (diffuse + specular);
}

// calculates the color when using a spot light.
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);

    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results

    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;

    return (diffuse + specular);
}

float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias)
{
    vec4 fragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0);

    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    // check whether current frag pos is in shadow
    // PCF
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias)
{

    // get vector between fragment position and light position
    vec3 fragToLight = FragPos - lightPos;
    float currentDepth = length(fragToLight);

    float shadow = 0.0;

    // Bias calc
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    int samples = 20;
    float viewDistance = length(viewPos - FragPos);
    float diskRadius = (1.0 + (viewDistance / farPlane)) / 500.0;

    for(int i = 0; i < samples; i++)
    {
        float closestDepth = texture(cubeMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= farPlane;   // undo mapping [0;1]
        if((currentDepth - bias) > closestDepth){
            shadow += 1.0;
        }
    }
    shadow /= float(samples);
    return shadow;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:108: '(' : syntax error: Array size must appear after variable name\n"
This renderer requires atleast OpenGL 3.2. The version available is: 2.1 ATI-3.5.5
QOpenGLShader::compile(Vertex): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:2: 'layout' : syntax error: syntax error

*** Problematic Vertex shader source code ***
#version 330 core
#define lowp
#define mediump
#define highp
#line 1
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoords = aTexCoords;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:2: 'layout' : syntax error: syntax error\n"
QOpenGLShader::compile(Fragment): ERROR: 0:1: '' :  version '330' is not supported
ERROR: 0:1: '' : syntax error: #version
ERROR: 0:108: '(' : syntax error: Array size must appear after variable name

*** Problematic Fragment shader source code ***
#version 330 core
#ifdef GL_KHR_blend_equation_advanced
#extension GL_ARB_fragment_coord_conventions : enable
#extension GL_KHR_blend_equation_advanced : enable
#endif
#define lowp
#define mediump
#define highp
#line 1

struct Material {
    vec4 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct DirLight {
    vec3 position; // specifically for shadows
    vec3 direction;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float farPlane;
    float bias;
    float normalBias;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;

    float constant;
    float linear;
    float quadratic;

//    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    mat4 lightSpaceMatrix;
    sampler2D shadowMap;
    float bias;
    float normalBias;
};

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

uniform sampler2D texture0;
uniform int textureApplyMode;

uniform vec3 sceneAmbient;
uniform vec3 viewPos;

// Some graphics cards appear not to support arrays. One way around this is to explicitly roll out the array.
#define MAX_LIGHTS 5
uniform DirLight dirLight0;
uniform DirLight dirLight1;
uniform DirLight dirLight2;
uniform DirLight dirLight3;
uniform DirLight dirLight4;

uniform PointLight pointLight0;
uniform PointLight pointLight1;
uniform PointLight pointLight2;
uniform PointLight pointLight3;
uniform PointLight pointLight4;

uniform SpotLight spotLight0;
uniform SpotLight spotLight1;
uniform SpotLight spotLight2;
uniform SpotLight spotLight3;
uniform SpotLight spotLight4;

// For some reason, we are not allowed to store samplerCube in structs or arrays
// So allow a max of 5
uniform samplerCube depthCubeMap0;
uniform samplerCube depthCubeMap1;
uniform samplerCube depthCubeMap2;
uniform samplerCube depthCubeMap3;
uniform samplerCube depthCubeMap4;

uniform int dirLightLen;
uniform int pointLightLen;
uniform int spotLightLen;

uniform Material material;

// array of offset direction for sampling in pointlight shadows
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1),
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

// function prototypes
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias);
float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias);

void main()
{
    // Lighting properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // Give it some intial ambient light
    vec4 ambient = texture(texture0, TexCoords);

    // textureApplyMode 1 (GL_DECAL) gets applied later.
    if (textureApplyMode == 2)  // ADD
        ambient = (ambient + material.ambient, 1.0) * vec4(sceneAmbient, 1.0);
    else if (textureApplyMode == 1)
        ambient = material.ambient;
    else if (textureApplyMode != 1)
        // In this case, we either have no texture, or we want to use GL_BLEND.
        ambient *= material.ambient * vec4(sceneAmbient, 1.0);

    vec3 result = vec3(0.0);
    // phase 1: directional lighting
    for(int i = 0; i < dirLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcDirLight(dirLight0, norm, viewDir);
            shadow = ShadowCalculation(dirLight0.lightSpaceMatrix, dirLight0.position, dirLight0.shadowMap, dirLight0.bias, dirLight0.normalBias);
        } else if (i == 1){
            lresult = CalcDirLight(dirLight1, norm, viewDir);
            shadow = ShadowCalculation(dirLight1.lightSpaceMatrix, dirLight1.position, dirLight1.shadowMap, dirLight1.bias, dirLight1.normalBias);
        } else if (i == 2){
            lresult = CalcDirLight(dirLight2, norm, viewDir);
            shadow = ShadowCalculation(dirLight2.lightSpaceMatrix, dirLight2.position, dirLight2.shadowMap, dirLight2.bias, dirLight2.normalBias);
        } else if (i == 3){
            lresult = CalcDirLight(dirLight3, norm, viewDir);
            shadow = ShadowCalculation(dirLight3.lightSpaceMatrix, dirLight3.position, dirLight3.shadowMap, dirLight3.bias, dirLight3.normalBias);
        } else if (i == 4){
            lresult = CalcDirLight(dirLight4, norm, viewDir);
            shadow = ShadowCalculation(dirLight4.lightSpaceMatrix, dirLight4.position, dirLight4.shadowMap, dirLight4.bias, dirLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 2: point lights
    for(int i = 0; i < pointLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;

        if (i == 0){
            lresult = CalcPointLight(pointLight0, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight0.position, depthCubeMap0, pointLight0.farPlane, pointLight0.bias, pointLight0.normalBias);
        }else if (i == 1){
            lresult = CalcPointLight(pointLight1, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight1.position, depthCubeMap1, pointLight1.farPlane, pointLight1.bias, pointLight1.normalBias);
        }else if (i == 2){
            lresult = CalcPointLight(pointLight2, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight2.position, depthCubeMap2, pointLight2.farPlane, pointLight2.bias, pointLight2.normalBias);
        }else if (i == 3){
            lresult = CalcPointLight(pointLight3, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight3.position, depthCubeMap3, pointLight3.farPlane, pointLight3.bias, pointLight3.normalBias);
        }else if (i == 4){
            lresult = CalcPointLight(pointLight4, norm, FragPos, viewDir);
            shadow = PointShadowCalculation(pointLight4.position, depthCubeMap4, pointLight4.farPlane, pointLight4.bias, pointLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }
    // phase 3: spot light
    for(int i = 0; i < spotLightLen && i < MAX_LIGHTS; i++)
    {
        vec3 lresult;
        float shadow = 0.0;
        // We are not allowed to store the struct in a temp, apparently.
        if (i == 0){
            lresult = CalcSpotLight(spotLight0, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight0.lightSpaceMatrix, spotLight0.position, spotLight0.shadowMap, spotLight0.bias, spotLight0.normalBias);
        } else if (i == 1){
            lresult = CalcSpotLight(spotLight1, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight1.lightSpaceMatrix, spotLight1.position, spotLight1.shadowMap, spotLight1.bias, spotLight1.normalBias);
        } else if (i == 2){
            lresult = CalcSpotLight(spotLight2, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight2.lightSpaceMatrix, spotLight2.position, spotLight2.shadowMap, spotLight2.bias, spotLight2.normalBias);
        } else if (i == 3){
            lresult = CalcSpotLight(spotLight3, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight3.lightSpaceMatrix, spotLight3.position, spotLight3.shadowMap, spotLight3.bias, spotLight3.normalBias);
        } else if (i == 4){
            lresult = CalcSpotLight(spotLight4, norm, FragPos, viewDir);
            shadow = ShadowCalculation(spotLight4.lightSpaceMatrix, spotLight4.position, spotLight4.shadowMap, spotLight4.bias, spotLight4.normalBias);
        }
        result += lresult * (1.0 - shadow);
    }

    FragColor = ambient + vec4(result, 0.0);
    if (textureApplyMode == 1){
        // textureApplyMode == 1 is DECAL
        vec4 coltex = texture(texture0, TexCoords.st);
        vec3 col = FragColor.rgb * (1.0-coltex.a) + coltex.rgb * coltex.a;
        FragColor = vec4(col, FragColor.a);
    }
}

// calculates the color when using a directional light.
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading (Phong)
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    // specular shading (Blinn-Phong)
    // vec3 halfwayDir = normalize(lightDir + viewDir);
    // float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);

    // combine results
    vec3 diffuse = light.diffuse * (diff * (vec3(texture(texture0, TexCoords)) * material.diffuse));
    vec3 specular = light.specular * (spec * (vec3(texture(texture0, TexCoords)) * material.specular));
    return (diffuse + specular);
}

// calculates the color when using a point light.
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // combine results
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation;
    specular *= attenuation;
    return (diffuse + specular);
}

// calculates the color when using a spot light.
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);

    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results

    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);

    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;

    return (diffuse + specular);
}

float ShadowCalculation(mat4 lightSpaceMatrix, vec3 lightPos, sampler2D shadowMap, float bias, float normalBias)
{
    vec4 fragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0);

    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    // check whether current frag pos is in shadow
    // PCF
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

float PointShadowCalculation(vec3 lightPos, samplerCube cubeMap, float farPlane, float bias, float normalBias)
{

    // get vector between fragment position and light position
    vec3 fragToLight = FragPos - lightPos;
    float currentDepth = length(fragToLight);

    float shadow = 0.0;

    // Bias calc
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    bias = max(normalBias * (1.0 - dot(normal, lightDir)), bias);

    int samples = 20;
    float viewDistance = length(viewPos - FragPos);
    float diskRadius = (1.0 + (viewDistance / farPlane)) / 500.0;

    for(int i = 0; i < samples; i++)
    {
        float closestDepth = texture(cubeMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= farPlane;   // undo mapping [0;1]
        if((currentDepth - bias) > closestDepth){
            shadow += 1.0;
        }
    }
    shadow /= float(samples);
    return shadow;
}

***
"ERROR: 0:1: '' :  version '330' is not supported\nERROR: 0:1: '' : syntax error: #version\nERROR: 0:108: '(' : syntax error: Array size must appear after variable name\n"
Actor(
  (backbones): Backbones(
    (hidden): ModuleList(
      (0): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (1): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (2): Sequential(
        (0): Linear(in_features=3, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
    )
    (cnn_tail): ModuleList()
  )
  (fc_body): Sequential(
    (0): Linear(in_features=96, out_features=128, bias=True)
    (1): LeakyReLU(negative_slope=0.01, inplace=True)
    (2): Linear(in_features=128, out_features=128, bias=True)
    (3): LeakyReLU(negative_slope=0.01, inplace=True)
    (4): Linear(in_features=128, out_features=8, bias=True)
    (5): Tanh()
  )
)
Critic(
  (backbones): Backbones(
    (hidden): ModuleList(
      (0): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (1): Sequential(
        (0): Linear(in_features=7, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
      (2): Sequential(
        (0): Linear(in_features=3, out_features=32, bias=True)
        (1): ReLU(inplace=True)
      )
    )
    (cnn_tail): ModuleList()
  )
  (fc_body): Sequential(
    (0): Linear(in_features=96, out_features=128, bias=True)
    (1): LeakyReLU(negative_slope=0.01, inplace=True)
  )
  (critic_body): Sequential(
    (0): Linear(in_features=136, out_features=64, bias=True)
    (1): LeakyReLU(negative_slope=0.01, inplace=True)
    (2): Linear(in_features=64, out_features=1, bias=True)
  )
)
Episode 1	Exploration: 0.649000	Average Score: -0.21	Current Score: -0.21	Actor Loss: 0.00e+00	Critic Loss: 0.00e+00
Episode 2	Exploration: 0.648000	Average Score: -0.28	Current Score: -0.35	Actor Loss: 0.00e+00	Critic Loss: 0.00e+00
Episode 3	Exploration: 0.647000	Average Score: -0.28	Current Score: -0.27	Actor Loss: 1.09e+00	Critic Loss: 2.01e-03
Episode 4	Exploration: 0.646000	Average Score: -0.26	Current Score: -0.23	Actor Loss: 1.10e+00	Critic Loss: 8.07e-04
Episode 5	Exploration: 0.645000	Average Score: -0.28	Current Score: -0.34	Actor Loss: 1.12e+00	Critic Loss: 7.44e-04
Episode 6	Exploration: 0.644000	Average Score: -0.28	Current Score: -0.31	Actor Loss: 1.15e+00	Critic Loss: 1.94e-03
Episode 7	Exploration: 0.643000	Average Score: -0.28	Current Score: -0.28	Actor Loss: 1.21e+00	Critic Loss: 9.58e-04
Episode 8	Exploration: 0.642000	Average Score: -0.29	Current Score: -0.30	Actor Loss: 1.25e+00	Critic Loss: 5.87e-04
Episode 9	Exploration: 0.641000	Average Score: -0.29	Current Score: -0.32	Actor Loss: 1.23e+00	Critic Loss: 5.23e-04
Episode 10	Exploration: 0.640000	Average Score: -0.32	Current Score: -0.57	Actor Loss: 1.23e+00	Critic Loss: 8.39e-04
Episode 11	Exploration: 0.639000	Average Score: -0.33	Current Score: -0.40	Actor Loss: 1.33e+00	Critic Loss: 8.39e-04
Episode 12	Exploration: 0.638000	Average Score: -0.32	Current Score: -0.31	Actor Loss: 1.38e+00	Critic Loss: 8.11e-04
Episode 13	Exploration: 0.637000	Average Score: -0.32	Current Score: -0.28	Actor Loss: 1.41e+00	Critic Loss: 6.71e-04
Episode 14	Exploration: 0.636000	Average Score: -0.32	Current Score: -0.35	Actor Loss: 1.42e+00	Critic Loss: 5.63e-04
Episode 15	Exploration: 0.635000	Average Score: -0.32	Current Score: -0.24	Actor Loss: 1.38e+00	Critic Loss: 1.47e-03
Episode 16	Exploration: 0.634000	Average Score: -0.32	Current Score: -0.34	Actor Loss: 1.54e+00	Critic Loss: 2.11e-03
Episode 17	Exploration: 0.633000	Average Score: -0.32	Current Score: -0.30	Actor Loss: 1.49e+00	Critic Loss: 2.32e-03
Episode 18	Exploration: 0.632000	Average Score: -0.32	Current Score: -0.35	Actor Loss: 1.50e+00	Critic Loss: 2.39e-03
Episode 19	Exploration: 0.631000	Average Score: -0.33	Current Score: -0.44	Actor Loss: 1.48e+00	Critic Loss: 1.99e-03
Episode 20	Exploration: 0.630000	Average Score: -0.32	Current Score: -0.29	Actor Loss: 1.47e+00	Critic Loss: 3.57e-03
Episode 21	Exploration: 0.629720	Average Score: -0.31	Current Score: -0.06	Actor Loss: 1.50e+00	Critic Loss: 2.64e-03
Episode 22	Exploration: 0.628720	Average Score: -0.31	Current Score: -0.24	Actor Loss: 1.52e+00	Critic Loss: 3.85e-02
Episode 23	Exploration: 0.627720	Average Score: -0.31	Current Score: -0.41	Actor Loss: 1.42e+00	Critic Loss: 6.63e-02
Episode 24	Exploration: 0.626720	Average Score: -0.31	Current Score: -0.37	Actor Loss: 1.47e+00	Critic Loss: 3.27e-02
Episode 25	Exploration: 0.625720	Average Score: -0.31	Current Score: -0.30	Actor Loss: 1.69e+00	Critic Loss: 7.61e-03
Episode 26	Exploration: 0.624720	Average Score: -0.31	Current Score: -0.18	Actor Loss: 1.55e+00	Critic Loss: 3.13e-03
Episode 27	Exploration: 0.623720	Average Score: -0.31	Current Score: -0.31	Actor Loss: 1.60e+00	Critic Loss: 2.46e-03
Episode 28	Exploration: 0.622720	Average Score: -0.31	Current Score: -0.22	Actor Loss: 1.64e+00	Critic Loss: 3.31e-02
Episode 29	Exploration: 0.621720	Average Score: -0.30	Current Score: -0.22	Actor Loss: 1.54e+00	Critic Loss: 2.87e-03
Episode 30	Exploration: 0.621700	Average Score: -0.23	Current Score: 1.94	Actor Loss: 1.58e+00	Critic Loss: 4.98e-03
Episode 31	Exploration: 0.620700	Average Score: -0.23	Current Score: -0.29	Actor Loss: 1.54e+00	Critic Loss: 3.64e-02
Episode 32	Exploration: 0.619700	Average Score: -0.24	Current Score: -0.40	Actor Loss: 1.55e+00	Critic Loss: 3.37e-02
Episode 33	Exploration: 0.618700	Average Score: -0.25	Current Score: -0.55	Actor Loss: 1.55e+00	Critic Loss: 3.08e-03
Episode 34	Exploration: 0.617700	Average Score: -0.25	Current Score: -0.25	Actor Loss: 1.59e+00	Critic Loss: 2.92e-03
Episode 35	Exploration: 0.616700	Average Score: -0.25	Current Score: -0.24	Actor Loss: 1.63e+00	Critic Loss: 3.15e-03
Episode 36	Exploration: 0.615700	Average Score: -0.25	Current Score: -0.50	Actor Loss: 1.52e+00	Critic Loss: 7.24e-03
Episode 37	Exploration: 0.614700	Average Score: -0.25	Current Score: -0.34	Actor Loss: 1.68e+00	Critic Loss: 4.31e-03
Episode 38	Exploration: 0.613700	Average Score: -0.26	Current Score: -0.28	Actor Loss: 1.60e+00	Critic Loss: 7.17e-02
Episode 39	Exploration: 0.612700	Average Score: -0.26	Current Score: -0.42	Actor Loss: 1.61e+00	Critic Loss: 7.65e-03
Episode 40	Exploration: 0.611700	Average Score: -0.26	Current Score: -0.32	Actor Loss: 1.69e+00	Critic Loss: 6.98e-02
Episode 41	Exploration: 0.610700	Average Score: -0.26	Current Score: -0.28	Actor Loss: 1.67e+00	Critic Loss: 4.63e-03
Episode 42	Exploration: 0.609700	Average Score: -0.26	Current Score: -0.30	Actor Loss: 1.69e+00	Critic Loss: 5.07e-03
Episode 43	Exploration: 0.608700	Average Score: -0.26	Current Score: -0.15	Actor Loss: 1.69e+00	Critic Loss: 7.41e-03
Episode 44	Exploration: 0.607700	Average Score: -0.26	Current Score: -0.18	Actor Loss: 1.68e+00	Critic Loss: 3.91e-03
Episode 45	Exploration: 0.606700	Average Score: -0.26	Current Score: -0.26	Actor Loss: 1.69e+00	Critic Loss: 4.81e-03
Episode 46	Exploration: 0.605700	Average Score: -0.26	Current Score: -0.17	Actor Loss: 1.76e+00	Critic Loss: 3.93e-03
Episode 47	Exploration: 0.605560	Average Score: -0.25	Current Score: 0.11	Actor Loss: 1.71e+00	Critic Loss: 4.12e-03
Episode 48	Exploration: 0.604560	Average Score: -0.25	Current Score: -0.20	Actor Loss: 1.65e+00	Critic Loss: 3.69e-03
Episode 49	Exploration: 0.604140	Average Score: -0.24	Current Score: -0.12	Actor Loss: 1.69e+00	Critic Loss: 4.81e-03
Episode 50	Exploration: 0.603140	Average Score: -0.24	Current Score: -0.19	Actor Loss: 1.69e+00	Critic Loss: 3.18e-02
Save Model
Episode 50	Average Score: -0.24
Episode 51	Exploration: 0.602140	Average Score: -0.24	Current Score: -0.29	Actor Loss: 1.72e+00	Critic Loss: 4.07e-02
Episode 52	Exploration: 0.601140	Average Score: -0.25	Current Score: -0.42	Actor Loss: 1.76e+00	Critic Loss: 7.48e-03
Episode 53	Exploration: 0.600140	Average Score: -0.25	Current Score: -0.19	Actor Loss: 1.71e+00	Critic Loss: 4.19e-03
Episode 54	Exploration: 0.599140	Average Score: -0.25	Current Score: -0.32	Actor Loss: 1.74e+00	Critic Loss: 4.66e-02
Episode 55	Exploration: 0.598140	Average Score: -0.25	Current Score: -0.33	Actor Loss: 1.78e+00	Critic Loss: 7.27e-03
Episode 56	Exploration: 0.597140	Average Score: -0.25	Current Score: -0.23	Actor Loss: 1.64e+00	Critic Loss: 4.22e-02
Episode 57	Exploration: 0.596140	Average Score: -0.25	Current Score: -0.18	Actor Loss: 1.73e+00	Critic Loss: 9.64e-03
Episode 58	Exploration: 0.595140	Average Score: -0.25	Current Score: -0.16	Actor Loss: 1.71e+00	Critic Loss: 3.25e-02
Episode 59	Exploration: 0.594140	Average Score: -0.25	Current Score: -0.23	Actor Loss: 1.72e+00	Critic Loss: 3.33e-02
Episode 60	Exploration: 0.593140	Average Score: -0.25	Current Score: -0.32	Actor Loss: 1.66e+00	Critic Loss: 3.43e-02
Episode 61	Exploration: 0.592140	Average Score: -0.25	Current Score: -0.18	Actor Loss: 1.79e+00	Critic Loss: 3.24e-02
Episode 62	Exploration: 0.591140	Average Score: -0.25	Current Score: -0.27	Actor Loss: 1.74e+00	Critic Loss: 5.36e-03
Episode 63	Exploration: 0.590140	Average Score: -0.25	Current Score: -0.33	Actor Loss: 1.68e+00	Critic Loss: 6.49e-03
Episode 64	Exploration: 0.589140	Average Score: -0.25	Current Score: -0.29	Actor Loss: 1.85e+00	Critic Loss: 7.55e-03
Episode 65	Exploration: 0.588140	Average Score: -0.25	Current Score: -0.22	Actor Loss: 1.79e+00	Critic Loss: 8.45e-03
Episode 66	Exploration: 0.587140	Average Score: -0.25	Current Score: -0.18	Actor Loss: 1.79e+00	Critic Loss: 3.96e-02
Episode 67	Exploration: 0.586140	Average Score: -0.25	Current Score: -0.21	Actor Loss: 1.81e+00	Critic Loss: 1.34e-02
Episode 68	Exploration: 0.585140	Average Score: -0.25	Current Score: -0.20	Actor Loss: 1.79e+00	Critic Loss: 6.27e-03
Episode 69	Exploration: 0.584140	Average Score: -0.25	Current Score: -0.64	Actor Loss: 1.82e+00	Critic Loss: 7.17e-03
Episode 70	Exploration: 0.583960	Average Score: -0.25	Current Score: 0.06	Actor Loss: 1.82e+00	Critic Loss: 4.32e-03
Episode 71	Exploration: 0.582960	Average Score: -0.25	Current Score: -0.28	Actor Loss: 1.86e+00	Critic Loss: 3.21e-02
Episode 72	Exploration: 0.581960	Average Score: -0.25	Current Score: -0.31	Actor Loss: 1.75e+00	Critic Loss: 4.66e-02
Episode 73	Exploration: 0.580960	Average Score: -0.25	Current Score: -0.20	Actor Loss: 1.85e+00	Critic Loss: 3.24e-02
Episode 74	Exploration: 0.580840	Average Score: -0.24	Current Score: 0.06	Actor Loss: 1.77e+00	Critic Loss: 7.38e-02
Episode 75	Exploration: 0.579840	Average Score: -0.24	Current Score: -0.29	Actor Loss: 1.84e+00	Critic Loss: 5.82e-03
Episode 76	Exploration: 0.578840	Average Score: -0.24	Current Score: -0.16	Actor Loss: 1.84e+00	Critic Loss: 7.78e-03
Episode 77	Exploration: 0.577840	Average Score: -0.25	Current Score: -0.54	Actor Loss: 1.92e+00	Critic Loss: 6.89e-03
Episode 78	Exploration: 0.576840	Average Score: -0.25	Current Score: -0.33	Actor Loss: 1.82e+00	Critic Loss: 4.23e-02
Episode 79	Exploration: 0.575840	Average Score: -0.25	Current Score: -0.35	Actor Loss: 1.79e+00	Critic Loss: 6.16e-03
Episode 80	Exploration: 0.574840	Average Score: -0.25	Current Score: -0.29	Actor Loss: 1.86e+00	Critic Loss: 6.03e-03
Episode 81	Exploration: 0.573840	Average Score: -0.25	Current Score: -0.25	Actor Loss: 1.90e+00	Critic Loss: 4.47e-02
Episode 82	Exploration: 0.572840	Average Score: -0.25	Current Score: -0.41	Actor Loss: 1.90e+00	Critic Loss: 1.00e-02
Episode 83	Exploration: 0.571840	Average Score: -0.25	Current Score: -0.17	Actor Loss: 1.80e+00	Critic Loss: 1.04e-01
Episode 84	Exploration: 0.570840	Average Score: -0.25	Current Score: -0.53	Actor Loss: 1.97e+00	Critic Loss: 1.26e-02
Episode 85	Exploration: 0.569840	Average Score: -0.25	Current Score: -0.20	Actor Loss: 1.92e+00	Critic Loss: 1.15e-02
Episode 86	Exploration: 0.568840	Average Score: -0.26	Current Score: -0.52	Actor Loss: 1.93e+00	Critic Loss: 7.76e-03
Episode 87	Exploration: 0.567840	Average Score: -0.26	Current Score: -0.31	Actor Loss: 1.91e+00	Critic Loss: 5.26e-03
Episode 88	Exploration: 0.566840	Average Score: -0.26	Current Score: -0.11	Actor Loss: 1.94e+00	Critic Loss: 9.39e-03
Episode 89	Exploration: 0.565840	Average Score: -0.25	Current Score: -0.22	Actor Loss: 1.93e+00	Critic Loss: 4.16e-02
Episode 90	Exploration: 0.564840	Average Score: -0.26	Current Score: -0.37	Actor Loss: 2.06e+00	Critic Loss: 1.09e-02
Episode 91	Exploration: 0.563840	Average Score: -0.26	Current Score: -0.36	Actor Loss: 2.01e+00	Critic Loss: 7.84e-03
Episode 92	Exploration: 0.562840	Average Score: -0.26	Current Score: -0.44	Actor Loss: 1.98e+00	Critic Loss: 1.64e-02
Episode 93	Exploration: 0.561840	Average Score: -0.26	Current Score: -0.37	Actor Loss: 2.11e+00	Critic Loss: 1.25e-02
Episode 94	Exploration: 0.560840	Average Score: -0.26	Current Score: -0.26	Actor Loss: 2.01e+00	Critic Loss: 6.76e-03
Episode 95	Exploration: 0.559840	Average Score: -0.26	Current Score: -0.23	Actor Loss: 2.03e+00	Critic Loss: 1.59e-02
Episode 96	Exploration: 0.558840	Average Score: -0.26	Current Score: -0.23	Actor Loss: 2.06e+00	Critic Loss: 1.15e-02
Episode 97	Exploration: 0.557840	Average Score: -0.26	Current Score: -0.24	Actor Loss: 1.98e+00	Critic Loss: 8.95e-03
Episode 98	Exploration: 0.556840	Average Score: -0.26	Current Score: -0.23	Actor Loss: 2.05e+00	Critic Loss: 3.32e-02
Episode 99	Exploration: 0.555840	Average Score: -0.26	Current Score: -0.22	Actor Loss: 2.03e+00	Critic Loss: 8.90e-03
Episode 100	Exploration: 0.554840	Average Score: -0.26	Current Score: -0.25	Actor Loss: 2.05e+00	Critic Loss: 3.32e-02
Episode 100	Average Score: -0.26
Save Model
Episode 100	Average Score: -0.26
Episode 101	Exploration: 0.553840	Average Score: -0.26	Current Score: -0.20	Actor Loss: 2.03e+00	Critic Loss: 2.94e-02
Episode 102	Exploration: 0.552840	Average Score: -0.26	Current Score: -0.22	Actor Loss: 2.03e+00	Critic Loss: 1.07e-02
Episode 103	Exploration: 0.551840	Average Score: -0.26	Current Score: -0.12	Actor Loss: 2.09e+00	Critic Loss: 9.18e-03
Episode 104	Exploration: 0.550840	Average Score: -0.26	Current Score: -0.18	Actor Loss: 2.09e+00	Critic Loss: 1.20e-02
Episode 105	Exploration: 0.549840	Average Score: -0.26	Current Score: -0.42	Actor Loss: 2.18e+00	Critic Loss: 2.30e-02
Episode 106	Exploration: 0.548840	Average Score: -0.26	Current Score: -0.27	Actor Loss: 2.09e+00	Critic Loss: 1.05e-02
Episode 107	Exploration: 0.547840	Average Score: -0.26	Current Score: -0.23	Actor Loss: 2.13e+00	Critic Loss: 1.20e-02
Episode 108	Exploration: 0.546840	Average Score: -0.26	Current Score: -0.34	Actor Loss: 2.11e+00	Critic Loss: 8.86e-03
Episode 109	Exploration: 0.545840	Average Score: -0.25	Current Score: -0.19	Actor Loss: 2.16e+00	Critic Loss: 1.03e-02
Episode 110	Exploration: 0.544840	Average Score: -0.25	Current Score: -0.14	Actor Loss: 2.15e+00	Critic Loss: 1.08e-02
Episode 111	Exploration: 0.543840	Average Score: -0.25	Current Score: -0.28	Actor Loss: 2.06e+00	Critic Loss: 6.70e-03
Episode 112	Exploration: 0.542840	Average Score: -0.25	Current Score: -0.27	Actor Loss: 2.16e+00	Critic Loss: 8.49e-03
Episode 113	Exploration: 0.541840	Average Score: -0.25	Current Score: -0.22	Actor Loss: 2.27e+00	Critic Loss: 1.49e-02
Episode 114	Exploration: 0.540840	Average Score: -0.25	Current Score: -0.19	Actor Loss: 2.07e+00	Critic Loss: 7.27e-03
Episode 115	Exploration: 0.539840	Average Score: -0.25	Current Score: -0.22	Actor Loss: 2.25e+00	Critic Loss: 1.09e-02
Episode 116	Exploration: 0.538840	Average Score: -0.25	Current Score: -0.23	Actor Loss: 2.23e+00	Critic Loss: 1.27e-02
Episode 117	Exploration: 0.537840	Average Score: -0.24	Current Score: -0.23	Actor Loss: 2.18e+00	Critic Loss: 3.53e-02
Episode 118	Exploration: 0.536840	Average Score: -0.24	Current Score: -0.25	Actor Loss: 2.22e+00	Critic Loss: 2.44e-02
Episode 119	Exploration: 0.535840	Average Score: -0.24	Current Score: -0.27	Actor Loss: 2.19e+00	Critic Loss: 1.17e-02
Episode 120	Exploration: 0.534840	Average Score: -0.24	Current Score: -0.43	Actor Loss: 2.14e+00	Critic Loss: 9.20e-03
Episode 121	Exploration: 0.534540	Average Score: -0.24	Current Score: -0.05	Actor Loss: 2.12e+00	Critic Loss: 1.19e-02
Episode 122	Exploration: 0.533540	Average Score: -0.24	Current Score: -0.43	Actor Loss: 2.23e+00	Critic Loss: 9.92e-03
Episode 123	Exploration: 0.532540	Average Score: -0.24	Current Score: -0.31	Actor Loss: 2.21e+00	Critic Loss: 8.89e-03
Episode 124	Exploration: 0.531540	Average Score: -0.24	Current Score: -0.35	Actor Loss: 2.13e+00	Critic Loss: 8.13e-03
Episode 125	Exploration: 0.530540	Average Score: -0.24	Current Score: -0.33	Actor Loss: 2.26e+00	Critic Loss: 8.24e-03
Episode 126	Exploration: 0.529540	Average Score: -0.24	Current Score: -0.22	Actor Loss: 2.21e+00	Critic Loss: 8.73e-03
Episode 127	Exploration: 0.528540	Average Score: -0.24	Current Score: -0.19	Actor Loss: 2.21e+00	Critic Loss: 1.20e-02
Episode 128	Exploration: 0.527540	Average Score: -0.24	Current Score: -0.19	Actor Loss: 2.21e+00	Critic Loss: 2.25e-02
Episode 129	Exploration: 0.526540	Average Score: -0.24	Current Score: -0.33	Actor Loss: 2.28e+00	Critic Loss: 4.08e-02
Episode 130	Exploration: 0.525540	Average Score: -0.27	Current Score: -0.47	Actor Loss: 2.31e+00	Critic Loss: 7.21e-03
Episode 131	Exploration: 0.524540	Average Score: -0.27	Current Score: -0.30	Actor Loss: 2.31e+00	Critic Loss: 1.27e-02
Episode 132	Exploration: 0.523540	Average Score: -0.27	Current Score: -0.21	Actor Loss: 2.42e+00	Critic Loss: 1.06e-02
Episode 133	Exploration: 0.522540	Average Score: -0.26	Current Score: -0.16	Actor Loss: 2.39e+00	Critic Loss: 1.12e-02
Episode 134	Exploration: 0.521540	Average Score: -0.26	Current Score: -0.27	Actor Loss: 2.30e+00	Critic Loss: 1.32e-02
Episode 135	Exploration: 0.520540	Average Score: -0.26	Current Score: -0.30	Actor Loss: 2.35e+00	Critic Loss: 3.93e-02
Episode 136	Exploration: 0.520280	Average Score: -0.26	Current Score: -0.05	Actor Loss: 2.38e+00	Critic Loss: 9.60e-03
Episode 137	Exploration: 0.520000	Average Score: -0.26	Current Score: -0.00	Actor Loss: 2.31e+00	Critic Loss: 1.96e-02
Episode 138	Exploration: 0.519000	Average Score: -0.26	Current Score: -0.24	Actor Loss: 2.37e+00	Critic Loss: 1.36e-02
Episode 139	Exploration: 0.518000	Average Score: -0.25	Current Score: -0.32	Actor Loss: 2.36e+00	Critic Loss: 2.43e-02
Episode 140	Exploration: 0.517000	Average Score: -0.25	Current Score: -0.38	Actor Loss: 2.37e+00	Critic Loss: 1.14e-02
Episode 141	Exploration: 0.516000	Average Score: -0.25	Current Score: -0.26	Actor Loss: 2.30e+00	Critic Loss: 1.67e-02
Episode 142	Exploration: 0.515000	Average Score: -0.25	Current Score: -0.24	Actor Loss: 2.41e+00	Critic Loss: 8.56e-03
Episode 143	Exploration: 0.514800	Average Score: -0.25	Current Score: 0.00	Actor Loss: 2.45e+00	Critic Loss: 1.21e-02
Episode 144	Exploration: 0.513800	Average Score: -0.26	Current Score: -0.46	Actor Loss: 2.44e+00	Critic Loss: 7.76e-03
Episode 145	Exploration: 0.512800	Average Score: -0.25	Current Score: -0.19	Actor Loss: 2.42e+00	Critic Loss: 2.91e-02
Episode 146	Exploration: 0.512440	Average Score: -0.25	Current Score: 0.03	Actor Loss: 2.44e+00	Critic Loss: 1.10e-02
Episode 147	Exploration: 0.511440	Average Score: -0.26	Current Score: -0.20	Actor Loss: 2.43e+00	Critic Loss: 4.97e-02
Episode 148	Exploration: 0.510440	Average Score: -0.26	Current Score: -0.31	Actor Loss: 2.39e+00	Critic Loss: 1.90e-01
Episode 149	Exploration: 0.509980	Average Score: -0.26	Current Score: -0.09	Actor Loss: 2.45e+00	Critic Loss: 1.46e-02
Episode 150	Exploration: 0.508980	Average Score: -0.26	Current Score: -0.18	Actor Loss: 2.38e+00	Critic Loss: 3.58e-02
Save Model
Episode 150	Average Score: -0.26
Episode 151	Exploration: 0.507980	Average Score: -0.26	Current Score: -0.27	Actor Loss: 2.47e+00	Critic Loss: 2.15e-02
Episode 152	Exploration: 0.506980	Average Score: -0.26	Current Score: -0.31	Actor Loss: 2.30e+00	Critic Loss: 9.25e-02
Episode 153	Exploration: 0.505980	Average Score: -0.25	Current Score: -0.12	Actor Loss: 2.33e+00	Critic Loss: 2.11e-02
Episode 154	Exploration: 0.504980	Average Score: -0.25	Current Score: -0.31	Actor Loss: 2.49e+00	Critic Loss: 1.48e-02
Episode 155	Exploration: 0.503980	Average Score: -0.25	Current Score: -0.11	Actor Loss: 2.41e+00	Critic Loss: 3.90e-02
Episode 156	Exploration: 0.502980	Average Score: -0.25	Current Score: -0.25	Actor Loss: 2.53e+00	Critic Loss: 9.52e-03
Episode 157	Exploration: 0.501980	Average Score: -0.25	Current Score: -0.27	Actor Loss: 2.37e+00	Critic Loss: 3.53e-02
Episode 158	Exploration: 0.500980	Average Score: -0.26	Current Score: -0.44	Actor Loss: 2.54e+00	Critic Loss: 1.03e-02
Episode 159	Exploration: 0.499980	Average Score: -0.26	Current Score: -0.15	Actor Loss: 2.41e+00	Critic Loss: 1.91e-02
Episode 160	Exploration: 0.498980	Average Score: -0.25	Current Score: -0.20	Actor Loss: 2.52e+00	Critic Loss: 1.05e-02
Episode 161	Exploration: 0.497980	Average Score: -0.26	Current Score: -0.52	Actor Loss: 2.52e+00	Critic Loss: 1.42e-02
Episode 162	Exploration: 0.496980	Average Score: -0.26	Current Score: -0.17	Actor Loss: 2.54e+00	Critic Loss: 1.57e-02
Episode 163	Exploration: 0.495980	Average Score: -0.26	Current Score: -0.22	Actor Loss: 2.47e+00	Critic Loss: 9.69e-03
Episode 164	Exploration: 0.494980	Average Score: -0.26	Current Score: -0.38	Actor Loss: 2.59e+00	Critic Loss: 2.68e-02
Episode 165	Exploration: 0.493980	Average Score: -0.26	Current Score: -0.30	Actor Loss: 2.55e+00	Critic Loss: 1.29e-02
Episode 166	Exploration: 0.492980	Average Score: -0.26	Current Score: -0.14	Actor Loss: 2.63e+00	Critic Loss: 1.49e-02
Episode 167	Exploration: 0.491980	Average Score: -0.26	Current Score: -0.24	Actor Loss: 2.50e+00	Critic Loss: 1.68e-02
Episode 168	Exploration: 0.490980	Average Score: -0.26	Current Score: -0.29	Actor Loss: 2.42e+00	Critic Loss: 7.77e-02
Episode 169	Exploration: 0.489980	Average Score: -0.25	Current Score: -0.18	Actor Loss: 2.48e+00	Critic Loss: 7.69e-02
Episode 170	Exploration: 0.488980	Average Score: -0.26	Current Score: -0.25	Actor Loss: 2.65e+00	Critic Loss: 1.88e-02
Episode 171	Exploration: 0.487980	Average Score: -0.26	Current Score: -0.44	Actor Loss: 2.52e+00	Critic Loss: 1.06e-02
Episode 172	Exploration: 0.486980	Average Score: -0.26	Current Score: -0.38	Actor Loss: 2.67e+00	Critic Loss: 1.64e-02
Episode 173	Exploration: 0.485980	Average Score: -0.26	Current Score: -0.23	Actor Loss: 2.67e+00	Critic Loss: 4.28e-02
Episode 174	Exploration: 0.485580	Average Score: -0.26	Current Score: -0.05	Actor Loss: 2.62e+00	Critic Loss: 1.22e-02
Episode 175	Exploration: 0.484580	Average Score: -0.26	Current Score: -0.18	Actor Loss: 2.54e+00	Critic Loss: 2.43e-02
Episode 176	Exploration: 0.483580	Average Score: -0.26	Current Score: -0.27	Actor Loss: 2.54e+00	Critic Loss: 1.41e-02
Episode 177	Exploration: 0.482580	Average Score: -0.26	Current Score: -0.14	Actor Loss: 2.63e+00	Critic Loss: 2.41e-02
Episode 178	Exploration: 0.481580	Average Score: -0.26	Current Score: -0.30	Actor Loss: 2.63e+00	Critic Loss: 2.25e-02
Episode 179	Exploration: 0.480580	Average Score: -0.26	Current Score: -0.36	Actor Loss: 2.53e+00	Critic Loss: 1.34e-02
Episode 180	Exploration: 0.479580	Average Score: -0.25	Current Score: -0.22	Actor Loss: 2.62e+00	Critic Loss: 1.71e-02
Episode 181	Exploration: 0.478580	Average Score: -0.26	Current Score: -0.37	Actor Loss: 2.63e+00	Critic Loss: 1.02e-02
Episode 182	Exploration: 0.477580	Average Score: -0.26	Current Score: -0.52	Actor Loss: 2.61e+00	Critic Loss: 1.80e-02
Episode 183	Exploration: 0.476580	Average Score: -0.26	Current Score: -0.20	Actor Loss: 2.54e+00	Critic Loss: 1.38e-02
Episode 184	Exploration: 0.475580	Average Score: -0.26	Current Score: -0.52	Actor Loss: 2.62e+00	Critic Loss: 1.59e-02
Episode 185	Exploration: 0.474580	Average Score: -0.26	Current Score: -0.16	Actor Loss: 2.59e+00	Critic Loss: 2.41e-02
Episode 186	Exploration: 0.473580	Average Score: -0.25	Current Score: -0.22	Actor Loss: 2.72e+00	Critic Loss: 1.37e-02
Episode 187	Exploration: 0.472580	Average Score: -0.26	Current Score: -0.45	Actor Loss: 2.75e+00	Critic Loss: 2.11e-02
Episode 188	Exploration: 0.471580	Average Score: -0.26	Current Score: -0.16	Actor Loss: 2.71e+00	Critic Loss: 2.17e-02
Episode 189	Exploration: 0.470580	Average Score: -0.26	Current Score: -0.17	Actor Loss: 2.75e+00	Critic Loss: 2.27e-02
Episode 190	Exploration: 0.469580	Average Score: -0.26	Current Score: -0.39	Actor Loss: 2.65e+00	Critic Loss: 1.69e-02
Episode 191	Exploration: 0.468580	Average Score: -0.26	Current Score: -0.68	Actor Loss: 2.65e+00	Critic Loss: 4.24e-02
Episode 192	Exploration: 0.467580	Average Score: -0.26	Current Score: -0.33	Actor Loss: 2.74e+00	Critic Loss: 9.59e-02
Episode 193	Exploration: 0.466580	Average Score: -0.26	Current Score: -0.15	Actor Loss: 2.80e+00	Critic Loss: 3.53e-02
Episode 194	Exploration: 0.465580	Average Score: -0.25	Current Score: -0.17	Actor Loss: 2.66e+00	Critic Loss: 4.91e-02
Episode 195	Exploration: 0.464580	Average Score: -0.26	Current Score: -0.32	Actor Loss: 2.68e+00	Critic Loss: 2.15e-02
Episode 196	Exploration: 0.464400	Average Score: -0.25	Current Score: 0.02	Actor Loss: 2.72e+00	Critic Loss: 2.05e-02
Episode 197	Exploration: 0.463400	Average Score: -0.25	Current Score: -0.25	Actor Loss: 2.84e+00	Critic Loss: 3.21e-02
Episode 198	Exploration: 0.462400	Average Score: -0.25	Current Score: -0.20	Actor Loss: 2.73e+00	Critic Loss: 2.07e-02
Episode 199	Exploration: 0.461400	Average Score: -0.25	Current Score: -0.22	Actor Loss: 2.81e+00	Critic Loss: 2.98e-02
Episode 200	Exploration: 0.461140	Average Score: -0.25	Current Score: 0.00	Actor Loss: 2.71e+00	Critic Loss: 2.91e-02
Episode 200	Average Score: -0.25
Save Model
Episode 200	Average Score: -0.25
Episode 201	Exploration: 0.460140	Average Score: -0.25	Current Score: -0.61	Actor Loss: 2.77e+00	Critic Loss: 1.80e-02
Episode 202	Exploration: 0.459140	Average Score: -0.26	Current Score: -0.30	Actor Loss: 2.77e+00	Critic Loss: 1.44e-02
Episode 203	Exploration: 0.458660	Average Score: -0.26	Current Score: -0.13	Actor Loss: 2.76e+00	Critic Loss: 1.31e-02
Episode 204	Exploration: 0.457660	Average Score: -0.26	Current Score: -0.27	Actor Loss: 2.85e+00	Critic Loss: 4.09e-02
Episode 205	Exploration: 0.456660	Average Score: -0.25	Current Score: -0.21	Actor Loss: 2.74e+00	Critic Loss: 1.34e-02
Episode 206	Exploration: 0.455660	Average Score: -0.25	Current Score: -0.12	Actor Loss: 2.69e+00	Critic Loss: 3.92e-02
Episode 207	Exploration: 0.454660	Average Score: -0.25	Current Score: -0.39	Actor Loss: 2.82e+00	Critic Loss: 1.96e-02
Episode 208	Exploration: 0.453660	Average Score: -0.25	Current Score: -0.20	Actor Loss: 2.80e+00	Critic Loss: 1.75e-02
Episode 209	Exploration: 0.453180	Average Score: -0.25	Current Score: -0.06	Actor Loss: 2.84e+00	Critic Loss: 9.49e-02
Episode 210	Exploration: 0.452180	Average Score: -0.25	Current Score: -0.21	Actor Loss: 2.83e+00	Critic Loss: 1.05e-01
Episode 211	Exploration: 0.451640	Average Score: -0.25	Current Score: -0.09	Actor Loss: 2.89e+00	Critic Loss: 1.99e-02
Episode 212	Exploration: 0.450640	Average Score: -0.25	Current Score: -0.25	Actor Loss: 2.89e+00	Critic Loss: 1.25e-01
Episode 213	Exploration: 0.449640	Average Score: -0.25	Current Score: -0.21	Actor Loss: 2.77e+00	Critic Loss: 1.77e-02
Episode 214	Exploration: 0.448640	Average Score: -0.25	Current Score: -0.19	Actor Loss: 2.78e+00	Critic Loss: 1.28e-01
Episode 215	Exploration: 0.447640	Average Score: -0.25	Current Score: -0.23	Actor Loss: 2.86e+00	Critic Loss: 2.11e-02
Episode 216	Exploration: 0.446640	Average Score: -0.25	Current Score: -0.41	Actor Loss: 2.85e+00	Critic Loss: 1.94e-02
Episode 217	Exploration: 0.445640	Average Score: -0.25	Current Score: -0.21	Actor Loss: 2.92e+00	Critic Loss: 2.65e-02
Episode 218	Exploration: 0.444640	Average Score: -0.25	Current Score: -0.17	Actor Loss: 3.02e+00	Critic Loss: 2.67e-02
Episode 219	Exploration: 0.443640	Average Score: -0.25	Current Score: -0.31	Actor Loss: 2.80e+00	Critic Loss: 1.80e-02
Episode 220	Exploration: 0.442640	Average Score: -0.25	Current Score: -0.24	Actor Loss: 2.92e+00	Critic Loss: 2.89e-02
Episode 221	Exploration: 0.441640	Average Score: -0.25	Current Score: -0.15	Actor Loss: 2.92e+00	Critic Loss: 6.74e-02
Episode 222	Exploration: 0.440640	Average Score: -0.25	Current Score: -0.12	Actor Loss: 2.95e+00	Critic Loss: 2.47e-02
Episode 223	Exploration: 0.439640	Average Score: -0.25	Current Score: -0.16	Actor Loss: 2.81e+00	Critic Loss: 1.29e-02
Episode 224	Exploration: 0.438640	Average Score: -0.24	Current Score: -0.19	Actor Loss: 2.87e+00	Critic Loss: 4.71e-02
Episode 225	Exploration: 0.437640	Average Score: -0.24	Current Score: -0.32	Actor Loss: 2.84e+00	Critic Loss: 9.72e-02
Episode 226	Exploration: 0.436640	Average Score: -0.24	Current Score: -0.13	Actor Loss: 2.93e+00	Critic Loss: 1.67e-02
Episode 227	Exploration: 0.435640	Average Score: -0.24	Current Score: -0.21	Actor Loss: 2.86e+00	Critic Loss: 1.23e-02
Episode 228	Exploration: 0.434640	Average Score: -0.24	Current Score: -0.20	Actor Loss: 2.86e+00	Critic Loss: 1.94e-02
Episode 229	Exploration: 0.433640	Average Score: -0.24	Current Score: -0.17	Actor Loss: 2.91e+00	Critic Loss: 2.92e-02
Episode 230	Exploration: 0.432640	Average Score: -0.24	Current Score: -0.19	Actor Loss: 2.77e+00	Critic Loss: 2.15e-02
Episode 231	Exploration: 0.431640	Average Score: -0.24	Current Score: -0.12	Actor Loss: 3.05e+00	Critic Loss: 1.39e-02
Episode 232	Exploration: 0.430640	Average Score: -0.24	Current Score: -0.18	Actor Loss: 2.87e+00	Critic Loss: 2.82e-02
Episode 233	Exploration: 0.429640	Average Score: -0.24	Current Score: -0.24	Actor Loss: 2.99e+00	Critic Loss: 1.73e-02
Episode 234	Exploration: 0.429120	Average Score: -0.24	Current Score: -0.19	Actor Loss: 2.79e+00	Critic Loss: 3.77e-02
Episode 235	Exploration: 0.428120	Average Score: -0.24	Current Score: -0.19	Actor Loss: 3.12e+00	Critic Loss: 8.00e-02
Episode 236	Exploration: 0.427120	Average Score: -0.24	Current Score: -0.29	Actor Loss: 2.94e+00	Critic Loss: 2.02e-02
Episode 237	Exploration: 0.426120	Average Score: -0.24	Current Score: -0.17	Actor Loss: 2.93e+00	Critic Loss: 2.02e-02
Episode 238	Exploration: 0.425120	Average Score: -0.24	Current Score: -0.39	Actor Loss: 3.00e+00	Critic Loss: 4.03e-02
Episode 239	Exploration: 0.424120	Average Score: -0.24	Current Score: -0.11	Actor Loss: 2.85e+00	Critic Loss: 2.31e-02
Episode 240	Exploration: 0.423120	Average Score: -0.24	Current Score: -0.17	Actor Loss: 2.99e+00	Critic Loss: 4.56e-02
Episode 241	Exploration: 0.422120	Average Score: -0.24	Current Score: -0.28	Actor Loss: 2.99e+00	Critic Loss: 8.45e-02
Episode 242	Exploration: 0.421120	Average Score: -0.24	Current Score: -0.22	Actor Loss: 2.99e+00	Critic Loss: 5.65e-02
Episode 243	Exploration: 0.420660	Average Score: -0.24	Current Score: -0.05	Actor Loss: 2.90e+00	Critic Loss: 2.46e-02
Episode 244	Exploration: 0.419680	Average Score: -0.23	Current Score: -0.13	Actor Loss: 3.02e+00	Critic Loss: 1.62e-02
Episode 245	Exploration: 0.418680	Average Score: -0.23	Current Score: -0.21	Actor Loss: 2.91e+00	Critic Loss: 6.40e-02
Episode 246	Exploration: 0.417680	Average Score: -0.24	Current Score: -0.24	Actor Loss: 2.95e+00	Critic Loss: 5.33e-02
Episode 247	Exploration: 0.416680	Average Score: -0.24	Current Score: -0.18	Actor Loss: 2.98e+00	Critic Loss: 2.30e-02
Episode 248	Exploration: 0.415680	Average Score: -0.24	Current Score: -0.42	Actor Loss: 2.91e+00	Critic Loss: 1.17e-01
Episode 249	Exploration: 0.414680	Average Score: -0.24	Current Score: -0.24	Actor Loss: 2.93e+00	Critic Loss: 1.75e-02
Episode 250	Exploration: 0.414480	Average Score: -0.24	Current Score: 0.01	Actor Loss: 2.90e+00	Critic Loss: 2.57e-02
Save Model
Episode 250	Average Score: -0.24
Episode 251	Exploration: 0.413480	Average Score: -0.24	Current Score: -0.21	Actor Loss: 2.87e+00	Critic Loss: 4.32e-02
Episode 252	Exploration: 0.412480	Average Score: -0.24	Current Score: -0.16	Actor Loss: 2.96e+00	Critic Loss: 2.31e-02
Episode 253	Exploration: 0.411480	Average Score: -0.24	Current Score: -0.15	Actor Loss: 3.07e+00	Critic Loss: 1.33e-01
Episode 254	Exploration: 0.410480	Average Score: -0.24	Current Score: -0.26	Actor Loss: 2.89e+00	Critic Loss: 1.10e-01
Episode 255	Exploration: 0.410240	Average Score: -0.24	Current Score: -0.08	Actor Loss: 3.03e+00	Critic Loss: 2.97e-02
Episode 256	Exploration: 0.409240	Average Score: -0.23	Current Score: -0.18	Actor Loss: 3.02e+00	Critic Loss: 8.82e-02
Episode 257	Exploration: 0.408240	Average Score: -0.23	Current Score: -0.21	Actor Loss: 2.83e+00	Critic Loss: 1.77e-02
Episode 258	Exploration: 0.407240	Average Score: -0.23	Current Score: -0.24	Actor Loss: 3.12e+00	Critic Loss: 2.07e-02
Episode 259	Exploration: 0.406240	Average Score: -0.23	Current Score: -0.18	Actor Loss: 2.95e+00	Critic Loss: 4.93e-02
Episode 260	Exploration: 0.405240	Average Score: -0.23	Current Score: -0.13	Actor Loss: 3.02e+00	Critic Loss: 8.38e-02
Episode 261	Exploration: 0.404240	Average Score: -0.23	Current Score: -0.17	Actor Loss: 3.04e+00	Critic Loss: 8.65e-02
Episode 262	Exploration: 0.403240	Average Score: -0.23	Current Score: -0.20	Actor Loss: 3.00e+00	Critic Loss: 2.66e-02
Episode 263	Exploration: 0.402240	Average Score: -0.23	Current Score: -0.34	Actor Loss: 2.97e+00	Critic Loss: 3.15e-02
Episode 264	Exploration: 0.401240	Average Score: -0.23	Current Score: -0.17	Actor Loss: 2.95e+00	Critic Loss: 3.84e-02
Episode 265	Exploration: 0.400240	Average Score: -0.23	Current Score: -0.14	Actor Loss: 3.15e+00	Critic Loss: 3.83e-02
Episode 266	Exploration: 0.399240	Average Score: -0.23	Current Score: -0.31	Actor Loss: 3.10e+00	Critic Loss: 1.61e-02
Episode 267	Exploration: 0.398240	Average Score: -0.23	Current Score: -0.16	Actor Loss: 2.89e+00	Critic Loss: 6.41e-02
Episode 268	Exploration: 0.397240	Average Score: -0.23	Current Score: -0.19	Actor Loss: 3.04e+00	Critic Loss: 2.08e-02
Episode 269	Exploration: 0.396240	Average Score: -0.23	Current Score: -0.20	Actor Loss: 2.93e+00	Critic Loss: 3.78e-02
Episode 270	Exploration: 0.396020	Average Score: -0.22	Current Score: -0.01	Actor Loss: 3.23e+00	Critic Loss: 2.24e-02
Episode 271	Exploration: 0.395020	Average Score: -0.22	Current Score: -0.30	Actor Loss: 3.01e+00	Critic Loss: 2.41e-02
Episode 272	Exploration: 0.394020	Average Score: -0.22	Current Score: -0.19	Actor Loss: 3.12e+00	Critic Loss: 7.46e-02
Episode 273	Exploration: 0.393020	Average Score: -0.22	Current Score: -0.20	Actor Loss: 3.02e+00	Critic Loss: 2.17e-02
Episode 274	Exploration: 0.392920	Average Score: -0.22	Current Score: 0.16	Actor Loss: 3.07e+00	Critic Loss: 5.86e-02
Episode 275	Exploration: 0.391920	Average Score: -0.22	Current Score: -0.17	Actor Loss: 3.09e+00	Critic Loss: 6.38e-02
Episode 276	Exploration: 0.390920	Average Score: -0.22	Current Score: -0.15	Actor Loss: 3.31e+00	Critic Loss: 1.76e-02
Episode 277	Exploration: 0.389920	Average Score: -0.22	Current Score: -0.21	Actor Loss: 3.00e+00	Critic Loss: 2.78e-02
Episode 278	Exploration: 0.388920	Average Score: -0.22	Current Score: -0.34	Actor Loss: 3.06e+00	Critic Loss: 3.96e-02
Episode 279	Exploration: 0.388700	Average Score: -0.21	Current Score: -0.06	Actor Loss: 3.16e+00	Critic Loss: 2.42e-02
Episode 280	Exploration: 0.387700	Average Score: -0.21	Current Score: -0.11	Actor Loss: 3.03e+00	Critic Loss: 2.86e-02
Episode 281	Exploration: 0.386700	Average Score: -0.21	Current Score: -0.44	Actor Loss: 3.16e+00	Critic Loss: 2.52e-02
Episode 282	Exploration: 0.385700	Average Score: -0.21	Current Score: -0.21	Actor Loss: 3.06e+00	Critic Loss: 1.46e-01
Episode 283	Exploration: 0.384700	Average Score: -0.21	Current Score: -0.27	Actor Loss: 3.03e+00	Critic Loss: 2.97e-02
Episode 284	Exploration: 0.383700	Average Score: -0.21	Current Score: -0.25	Actor Loss: 3.16e+00	Critic Loss: 3.07e-02
Episode 285	Exploration: 0.382700	Average Score: -0.21	Current Score: -0.19	Actor Loss: 3.07e+00	Critic Loss: 6.44e-02
Episode 286	Exploration: 0.381700	Average Score: -0.21	Current Score: -0.29	Actor Loss: 3.11e+00	Critic Loss: 2.54e-02
Episode 287	Exploration: 0.380700	Average Score: -0.21	Current Score: -0.11	Actor Loss: 3.21e+00	Critic Loss: 8.01e-02
Episode 288	Exploration: 0.379700	Average Score: -0.21	Current Score: -0.26	Actor Loss: 3.08e+00	Critic Loss: 2.60e-02
Episode 289	Exploration: 0.378700	Average Score: -0.21	Current Score: -0.40	Actor Loss: 3.35e+00	Critic Loss: 1.92e-02
Episode 290	Exploration: 0.377700	Average Score: -0.21	Current Score: -0.22	Actor Loss: 3.25e+00	Critic Loss: 2.62e-02
Episode 291	Exploration: 0.377640	Average Score: -0.20	Current Score: 0.44	Actor Loss: 3.17e+00	Critic Loss: 3.27e-02
Episode 292	Exploration: 0.376640	Average Score: -0.20	Current Score: -0.17	Actor Loss: 3.30e+00	Critic Loss: 2.26e-02
Episode 293	Exploration: 0.376080	Average Score: -0.20	Current Score: -0.14	Actor Loss: 3.27e+00	Critic Loss: 3.18e-02
Episode 294	Exploration: 0.375080	Average Score: -0.20	Current Score: -0.19	Actor Loss: 3.43e+00	Critic Loss: 2.40e-02
Episode 295	Exploration: 0.374080	Average Score: -0.19	Current Score: -0.22	Actor Loss: 3.13e+00	Critic Loss: 2.36e-02
Episode 296	Exploration: 0.373080	Average Score: -0.20	Current Score: -0.19	Actor Loss: 3.15e+00	Critic Loss: 8.51e-02
Episode 297	Exploration: 0.372080	Average Score: -0.20	Current Score: -0.31	Actor Loss: 3.22e+00	Critic Loss: 4.64e-02
Episode 298	Exploration: 0.371760	Average Score: -0.20	Current Score: -0.06	Actor Loss: 3.11e+00	Critic Loss: 2.69e-02
Episode 299	Exploration: 0.370760	Average Score: -0.19	Current Score: -0.12	Actor Loss: 3.23e+00	Critic Loss: 6.55e-02
Episode 300	Exploration: 0.369760	Average Score: -0.20	Current Score: -0.07	Actor Loss: 3.24e+00	Critic Loss: 3.37e-02
Episode 300	Average Score: -0.20
Save Model
Episode 300	Average Score: -0.20
Episode 301	Exploration: 0.369720	Average Score: -0.18	Current Score: 0.83	Actor Loss: 3.16e+00	Critic Loss: 3.41e-02
Episode 302	Exploration: 0.368720	Average Score: -0.18	Current Score: -0.26	Actor Loss: 3.24e+00	Critic Loss: 1.06e-01
Episode 303	Exploration: 0.367720	Average Score: -0.18	Current Score: -0.14	Actor Loss: 3.18e+00	Critic Loss: 3.90e-02
Episode 304	Exploration: 0.366720	Average Score: -0.18	Current Score: -0.24	Actor Loss: 3.36e+00	Critic Loss: 7.42e-02
Episode 305	Exploration: 0.365720	Average Score: -0.18	Current Score: -0.17	Actor Loss: 3.20e+00	Critic Loss: 6.04e-02
Episode 306	Exploration: 0.364720	Average Score: -0.18	Current Score: -0.20	Actor Loss: 3.26e+00	Critic Loss: 5.72e-02
Episode 307	Exploration: 0.363720	Average Score: -0.18	Current Score: -0.20	Actor Loss: 3.11e+00	Critic Loss: 2.03e-02
Episode 308	Exploration: 0.362720	Average Score: -0.18	Current Score: -0.27	Actor Loss: 3.25e+00	Critic Loss: 2.63e-02
Episode 309	Exploration: 0.362140	Average Score: -0.18	Current Score: -0.08	Actor Loss: 3.47e+00	Critic Loss: 1.87e-02
Episode 310	Exploration: 0.361420	Average Score: -0.18	Current Score: -0.14	Actor Loss: 3.38e+00	Critic Loss: 2.14e-02
Episode 311	Exploration: 0.360420	Average Score: -0.18	Current Score: -0.23	Actor Loss: 3.11e+00	Critic Loss: 3.29e-02
Episode 312	Exploration: 0.359420	Average Score: -0.18	Current Score: -0.15	Actor Loss: 3.28e+00	Critic Loss: 3.76e-02
Episode 313	Exploration: 0.358420	Average Score: -0.18	Current Score: -0.09	Actor Loss: 3.22e+00	Critic Loss: 2.22e-02
Episode 314	Exploration: 0.358180	Average Score: -0.18	Current Score: -0.06	Actor Loss: 3.34e+00	Critic Loss: 2.03e-01
Episode 315	Exploration: 0.357180	Average Score: -0.18	Current Score: -0.11	Actor Loss: 3.11e+00	Critic Loss: 1.07e-01
Episode 316	Exploration: 0.356180	Average Score: -0.17	Current Score: -0.23	Actor Loss: 3.31e+00	Critic Loss: 3.83e-02
Episode 317	Exploration: 0.355180	Average Score: -0.17	Current Score: -0.28	Actor Loss: 3.30e+00	Critic Loss: 3.01e-02
Episode 318	Exploration: 0.354180	Average Score: -0.18	Current Score: -0.23	Actor Loss: 3.22e+00	Critic Loss: 3.02e-02
Episode 319	Exploration: 0.353180	Average Score: -0.17	Current Score: -0.15	Actor Loss: 3.21e+00	Critic Loss: 2.15e-02
Episode 320	Exploration: 0.352660	Average Score: -0.17	Current Score: -0.09	Actor Loss: 3.28e+00	Critic Loss: 1.48e-01
Episode 321	Exploration: 0.351660	Average Score: -0.17	Current Score: -0.22	Actor Loss: 3.23e+00	Critic Loss: 4.32e-02
Episode 322	Exploration: 0.350660	Average Score: -0.17	Current Score: -0.28	Actor Loss: 3.33e+00	Critic Loss: 1.05e-01
Episode 323	Exploration: 0.349660	Average Score: -0.17	Current Score: -0.17	Actor Loss: 3.17e+00	Critic Loss: 3.56e-02
Episode 324	Exploration: 0.348660	Average Score: -0.18	Current Score: -0.32	Actor Loss: 3.40e+00	Critic Loss: 3.60e-02
Episode 325	Exploration: 0.347660	Average Score: -0.17	Current Score: -0.22	Actor Loss: 3.39e+00	Critic Loss: 2.46e-02
Episode 326	Exploration: 0.346660	Average Score: -0.18	Current Score: -0.22	Actor Loss: 3.44e+00	Critic Loss: 3.62e-02
Episode 327	Exploration: 0.345660	Average Score: -0.18	Current Score: -0.14	Actor Loss: 3.41e+00	Critic Loss: 1.21e-01
Episode 328	Exploration: 0.344660	Average Score: -0.17	Current Score: -0.19	Actor Loss: 3.11e+00	Critic Loss: 3.81e-02
Episode 329	Exploration: 0.344340	Average Score: -0.17	Current Score: -0.09	Actor Loss: 3.40e+00	Critic Loss: 2.51e-02
Episode 330	Exploration: 0.343340	Average Score: -0.17	Current Score: -0.15	Actor Loss: 3.51e+00	Critic Loss: 4.34e-02
Episode 331	Exploration: 0.342340	Average Score: -0.18	Current Score: -0.29	Actor Loss: 3.27e+00	Critic Loss: 4.67e-02
Episode 332	Exploration: 0.341340	Average Score: -0.18	Current Score: -0.17	Actor Loss: 3.31e+00	Critic Loss: 4.20e-02
Episode 333	Exploration: 0.340340	Average Score: -0.17	Current Score: -0.20	Actor Loss: 3.15e+00	Critic Loss: 3.22e-02
Episode 334	Exploration: 0.339340	Average Score: -0.18	Current Score: -0.28	Actor Loss: 3.25e+00	Critic Loss: 7.12e-02
Episode 335	Exploration: 0.338340	Average Score: -0.18	Current Score: -0.17	Actor Loss: 3.35e+00	Critic Loss: 4.59e-02
Episode 336	Exploration: 0.337340	Average Score: -0.17	Current Score: -0.14	Actor Loss: 3.38e+00	Critic Loss: 1.82e-02
Episode 337	Exploration: 0.337260	Average Score: -0.17	Current Score: 0.31	Actor Loss: 3.29e+00	Critic Loss: 3.78e-02
Episode 338	Exploration: 0.336260	Average Score: -0.17	Current Score: -0.13	Actor Loss: 3.37e+00	Critic Loss: 4.61e-02
Episode 339	Exploration: 0.335260	Average Score: -0.17	Current Score: -0.19	Actor Loss: 3.27e+00	Critic Loss: 4.80e-02
Episode 340	Exploration: 0.334260	Average Score: -0.17	Current Score: -0.15	Actor Loss: 3.22e+00	Critic Loss: 1.06e-01
Episode 341	Exploration: 0.333880	Average Score: -0.16	Current Score: 0.01	Actor Loss: 3.35e+00	Critic Loss: 3.39e-02
Episode 342	Exploration: 0.332880	Average Score: -0.16	Current Score: -0.18	Actor Loss: 3.30e+00	Critic Loss: 6.99e-02
Episode 343	Exploration: 0.331880	Average Score: -0.17	Current Score: -0.27	Actor Loss: 3.50e+00	Critic Loss: 3.22e-02
Episode 344	Exploration: 0.330880	Average Score: -0.17	Current Score: -0.17	Actor Loss: 3.41e+00	Critic Loss: 1.27e-01
Episode 345	Exploration: 0.329880	Average Score: -0.17	Current Score: -0.19	Actor Loss: 3.37e+00	Critic Loss: 2.30e-02
Episode 346	Exploration: 0.328880	Average Score: -0.17	Current Score: -0.18	Actor Loss: 3.31e+00	Critic Loss: 4.35e-02
Episode 347	Exploration: 0.327880	Average Score: -0.17	Current Score: -0.19	Actor Loss: 3.15e+00	Critic Loss: 5.70e-02
Episode 348	Exploration: 0.326880	Average Score: -0.16	Current Score: -0.24	Actor Loss: 3.50e+00	Critic Loss: 7.73e-02
Episode 349	Exploration: 0.325880	Average Score: -0.16	Current Score: -0.18	Actor Loss: 3.42e+00	Critic Loss: 3.32e-02
Episode 350	Exploration: 0.324880	Average Score: -0.17	Current Score: -0.13	Actor Loss: 3.23e+00	Critic Loss: 6.96e-02
Save Model
Episode 350	Average Score: -0.17
Episode 351	Exploration: 0.323880	Average Score: -0.17	Current Score: -0.30	Actor Loss: 3.29e+00	Critic Loss: 6.64e-02
Episode 352	Exploration: 0.322880	Average Score: -0.17	Current Score: -0.22	Actor Loss: 3.33e+00	Critic Loss: 3.62e-02
Episode 353	Exploration: 0.321880	Average Score: -0.17	Current Score: -0.18	Actor Loss: 3.42e+00	Critic Loss: 2.72e-02
Episode 354	Exploration: 0.320880	Average Score: -0.17	Current Score: -0.16	Actor Loss: 3.43e+00	Critic Loss: 4.29e-02
Episode 355	Exploration: 0.319880	Average Score: -0.17	Current Score: -0.36	Actor Loss: 3.37e+00	Critic Loss: 1.55e-01
Episode 356	Exploration: 0.318880	Average Score: -0.17	Current Score: -0.18	Actor Loss: 3.49e+00	Critic Loss: 9.34e-02
Episode 357	Exploration: 0.317880	Average Score: -0.17	Current Score: -0.24	Actor Loss: 3.31e+00	Critic Loss: 2.91e-02
Episode 358	Exploration: 0.316880	Average Score: -0.17	Current Score: -0.18	Actor Loss: 3.32e+00	Critic Loss: 8.60e-02
Episode 359	Exploration: 0.315880	Average Score: -0.17	Current Score: -0.16	Actor Loss: 3.45e+00	Critic Loss: 6.88e-02
Episode 360	Exploration: 0.314880	Average Score: -0.17	Current Score: -0.15	Actor Loss: 3.41e+00	Critic Loss: 1.88e-02
Episode 361	Exploration: 0.314560	Average Score: -0.17	Current Score: -0.05	Actor Loss: 3.41e+00	Critic Loss: 6.85e-02
Episode 362	Exploration: 0.313560	Average Score: -0.17	Current Score: -0.22	Actor Loss: 3.30e+00	Critic Loss: 8.06e-02
Episode 363	Exploration: 0.312560	Average Score: -0.17	Current Score: -0.13	Actor Loss: 3.33e+00	Critic Loss: 3.77e-02
Episode 364	Exploration: 0.312280	Average Score: -0.16	Current Score: -0.07	Actor Loss: 3.42e+00	Critic Loss: 4.00e-02
Episode 365	Exploration: 0.311340	Average Score: -0.16	Current Score: -0.10	Actor Loss: 3.48e+00	Critic Loss: 4.73e-02
Episode 366	Exploration: 0.310340	Average Score: -0.16	Current Score: -0.21	Actor Loss: 3.23e+00	Critic Loss: 3.65e-02
Episode 367	Exploration: 0.310140	Average Score: -0.16	Current Score: -0.02	Actor Loss: 3.51e+00	Critic Loss: 2.86e-02
Episode 368	Exploration: 0.309860	Average Score: -0.16	Current Score: -0.07	Actor Loss: 3.47e+00	Critic Loss: 1.50e-01
Episode 369	Exploration: 0.308860	Average Score: -0.16	Current Score: -0.21	Actor Loss: 3.24e+00	Critic Loss: 1.11e-01
Episode 370	Exploration: 0.307860	Average Score: -0.16	Current Score: -0.28	Actor Loss: 3.58e+00	Critic Loss: 3.00e-02
Episode 371	Exploration: 0.307440	Average Score: -0.16	Current Score: -0.07	Actor Loss: 3.47e+00	Critic Loss: 3.74e-02
Episode 372	Exploration: 0.306440	Average Score: -0.16	Current Score: -0.15	Actor Loss: 3.65e+00	Critic Loss: 6.79e-02
Episode 373	Exploration: 0.305440	Average Score: -0.16	Current Score: -0.16	Actor Loss: 3.34e+00	Critic Loss: 2.87e-02
Episode 374	Exploration: 0.304440	Average Score: -0.16	Current Score: -0.25	Actor Loss: 3.50e+00	Critic Loss: 1.65e-01
Episode 375	Exploration: 0.303820	Average Score: -0.16	Current Score: -0.10	Actor Loss: 3.56e+00	Critic Loss: 3.85e-02
Episode 376	Exploration: 0.302820	Average Score: -0.16	Current Score: -0.12	Actor Loss: 3.65e+00	Critic Loss: 6.00e-02
Episode 377	Exploration: 0.301820	Average Score: -0.16	Current Score: -0.25	Actor Loss: 3.42e+00	Critic Loss: 3.76e-02
Episode 378	Exploration: 0.301660	Average Score: -0.16	Current Score: 0.11	Actor Loss: 3.37e+00	Critic Loss: 7.65e-02
Episode 379	Exploration: 0.300660	Average Score: -0.16	Current Score: -0.14	Actor Loss: 3.36e+00	Critic Loss: 4.93e-02
Episode 380	Exploration: 0.299660	Average Score: -0.16	Current Score: -0.17	Actor Loss: 3.54e+00	Critic Loss: 2.48e-02
Episode 381	Exploration: 0.298660	Average Score: -0.16	Current Score: -0.15	Actor Loss: 3.30e+00	Critic Loss: 6.66e-02
Episode 382	Exploration: 0.298280	Average Score: -0.16	Current Score: -0.12	Actor Loss: 3.60e+00	Critic Loss: 8.57e-02
Episode 383	Exploration: 0.297280	Average Score: -0.16	Current Score: -0.16	Actor Loss: 3.45e+00	Critic Loss: 3.35e-02
Episode 384	Exploration: 0.296280	Average Score: -0.15	Current Score: -0.17	Actor Loss: 3.32e+00	Critic Loss: 4.84e-02
Episode 385	Exploration: 0.295280	Average Score: -0.16	Current Score: -0.28	Actor Loss: 3.36e+00	Critic Loss: 3.86e-02
Episode 386	Exploration: 0.294280	Average Score: -0.15	Current Score: -0.14	Actor Loss: 3.30e+00	Critic Loss: 3.78e-02
Episode 387	Exploration: 0.293280	Average Score: -0.15	Current Score: -0.12	Actor Loss: 3.54e+00	Critic Loss: 5.07e-02
Episode 388	Exploration: 0.293220	Average Score: -0.15	Current Score: 0.36	Actor Loss: 3.76e+00	Critic Loss: 4.86e-02
Episode 389	Exploration: 0.292220	Average Score: -0.15	Current Score: -0.14	Actor Loss: 3.55e+00	Critic Loss: 3.23e-02
Episode 390	Exploration: 0.291220	Average Score: -0.14	Current Score: -0.13	Actor Loss: 3.51e+00	Critic Loss: 4.85e-02
Episode 391	Exploration: 0.290220	Average Score: -0.15	Current Score: -0.23	Actor Loss: 3.51e+00	Critic Loss: 7.49e-02
Episode 392	Exploration: 0.289220	Average Score: -0.15	Current Score: -0.19	Actor Loss: 3.55e+00	Critic Loss: 3.76e-02
Episode 393	Exploration: 0.288220	Average Score: -0.15	Current Score: -0.13	Actor Loss: 3.56e+00	Critic Loss: 3.43e-02
Episode 394	Exploration: 0.287220	Average Score: -0.15	Current Score: -0.16	Actor Loss: 3.54e+00	Critic Loss: 6.99e-02
Episode 395	Exploration: 0.287040	Average Score: -0.15	Current Score: 0.07	Actor Loss: 3.50e+00	Critic Loss: 5.59e-02
Episode 396	Exploration: 0.286040	Average Score: -0.15	Current Score: -0.12	Actor Loss: 3.44e+00	Critic Loss: 4.97e-02
Episode 397	Exploration: 0.285040	Average Score: -0.15	Current Score: -0.21	Actor Loss: 3.35e+00	Critic Loss: 3.67e-02
Episode 398	Exploration: 0.284040	Average Score: -0.15	Current Score: -0.20	Actor Loss: 3.30e+00	Critic Loss: 9.62e-02
Episode 399	Exploration: 0.283040	Average Score: -0.15	Current Score: -0.13	Actor Loss: 3.66e+00	Critic Loss: 4.09e-02
Episode 400	Exploration: 0.282040	Average Score: -0.15	Current Score: -0.21	Actor Loss: 3.42e+00	Critic Loss: 4.65e-02
Episode 400	Average Score: -0.15
Save Model
Episode 400	Average Score: -0.15
Episode 401	Exploration: 0.281040	Average Score: -0.16	Current Score: -0.22	Actor Loss: 3.65e+00	Critic Loss: 3.88e-02
Episode 402	Exploration: 0.280040	Average Score: -0.16	Current Score: -0.16	Actor Loss: 3.69e+00	Critic Loss: 3.47e-02
Episode 403	Exploration: 0.279700	Average Score: -0.16	Current Score: -0.08	Actor Loss: 3.78e+00	Critic Loss: 7.87e-02
Episode 404	Exploration: 0.278700	Average Score: -0.16	Current Score: -0.14	Actor Loss: 3.43e+00	Critic Loss: 3.98e-02
Episode 405	Exploration: 0.277700	Average Score: -0.16	Current Score: -0.15	Actor Loss: 3.61e+00	Critic Loss: 6.05e-02
Episode 406	Exploration: 0.276700	Average Score: -0.16	Current Score: -0.17	Actor Loss: 3.47e+00	Critic Loss: 6.01e-02
Episode 407	Exploration: 0.276500	Average Score: -0.15	Current Score: 0.08	Actor Loss: 3.54e+00	Critic Loss: 6.40e-02
Episode 408	Exploration: 0.276420	Average Score: -0.15	Current Score: 0.39	Actor Loss: 3.57e+00	Critic Loss: 2.78e-02
Episode 409	Exploration: 0.276220	Average Score: -0.15	Current Score: 0.04	Actor Loss: 3.67e+00	Critic Loss: 2.68e-02
Episode 410	Exploration: 0.275220	Average Score: -0.15	Current Score: -0.18	Actor Loss: 3.44e+00	Critic Loss: 7.00e-02
Episode 411	Exploration: 0.274220	Average Score: -0.15	Current Score: -0.12	Actor Loss: 3.52e+00	Critic Loss: 1.16e-01
Episode 412	Exploration: 0.273220	Average Score: -0.15	Current Score: -0.14	Actor Loss: 3.21e+00	Critic Loss: 9.72e-02
Episode 413	Exploration: 0.272220	Average Score: -0.15	Current Score: -0.19	Actor Loss: 3.54e+00	Critic Loss: 9.31e-02
Episode 414	Exploration: 0.271860	Average Score: -0.15	Current Score: -0.13	Actor Loss: 3.66e+00	Critic Loss: 6.11e-02
Episode 415	Exploration: 0.270860	Average Score: -0.15	Current Score: -0.34	Actor Loss: 3.40e+00	Critic Loss: 7.01e-02
Episode 416	Exploration: 0.270620	Average Score: -0.15	Current Score: -0.07	Actor Loss: 3.45e+00	Critic Loss: 5.04e-02
Episode 417	Exploration: 0.269620	Average Score: -0.15	Current Score: -0.23	Actor Loss: 3.48e+00	Critic Loss: 1.01e-01
Episode 418	Exploration: 0.268620	Average Score: -0.15	Current Score: -0.30	Actor Loss: 3.50e+00	Critic Loss: 4.25e-02
Episode 419	Exploration: 0.267620	Average Score: -0.15	Current Score: -0.13	Actor Loss: 3.65e+00	Critic Loss: 2.91e-02
Episode 420	Exploration: 0.266960	Average Score: -0.15	Current Score: -0.16	Actor Loss: 3.42e+00	Critic Loss: 1.66e-01
Episode 421	Exploration: 0.265960	Average Score: -0.15	Current Score: -0.19	Actor Loss: 3.65e+00	Critic Loss: 8.24e-02
Episode 422	Exploration: 0.265300	Average Score: -0.15	Current Score: -0.08	Actor Loss: 3.51e+00	Critic Loss: 3.38e-02
Episode 423	Exploration: 0.264660	Average Score: -0.15	Current Score: -0.10	Actor Loss: 3.65e+00	Critic Loss: 6.60e-02
Episode 424	Exploration: 0.263660	Average Score: -0.14	Current Score: -0.17	Actor Loss: 3.46e+00	Critic Loss: 3.13e-02
Episode 425	Exploration: 0.262660	Average Score: -0.14	Current Score: -0.21	Actor Loss: 3.69e+00	Critic Loss: 3.87e-02
Episode 426	Exploration: 0.261660	Average Score: -0.14	Current Score: -0.19	Actor Loss: 3.60e+00	Critic Loss: 1.39e-01
Episode 427	Exploration: 0.260660	Average Score: -0.15	Current Score: -0.23	Actor Loss: 3.52e+00	Critic Loss: 1.40e-01
Episode 428	Exploration: 0.259660	Average Score: -0.15	Current Score: -0.18	Actor Loss: 3.70e+00	Critic Loss: 3.02e-02
Episode 429	Exploration: 0.258660	Average Score: -0.15	Current Score: -0.19	Actor Loss: 3.26e+00	Critic Loss: 1.74e-01
Episode 430	Exploration: 0.258480	Average Score: -0.14	Current Score: -0.00	Actor Loss: 3.65e+00	Critic Loss: 4.57e-02
Episode 431	Exploration: 0.257480	Average Score: -0.14	Current Score: -0.21	Actor Loss: 3.26e+00	Critic Loss: 1.34e-01
Episode 432	Exploration: 0.257420	Average Score: -0.14	Current Score: 0.52	Actor Loss: 3.37e+00	Critic Loss: 7.94e-02
Episode 433	Exploration: 0.256420	Average Score: -0.14	Current Score: -0.24	Actor Loss: 3.59e+00	Critic Loss: 1.77e-01
Episode 434	Exploration: 0.255420	Average Score: -0.14	Current Score: -0.19	Actor Loss: 3.77e+00	Critic Loss: 9.24e-02
Episode 435	Exploration: 0.254420	Average Score: -0.14	Current Score: -0.28	Actor Loss: 3.55e+00	Critic Loss: 1.27e-01
Episode 436	Exploration: 0.253420	Average Score: -0.14	Current Score: -0.25	Actor Loss: 3.38e+00	Critic Loss: 4.42e-02
Episode 437	Exploration: 0.252420	Average Score: -0.14	Current Score: -0.26	Actor Loss: 3.56e+00	Critic Loss: 1.11e-01
Episode 438	Exploration: 0.251420	Average Score: -0.14	Current Score: -0.14	Actor Loss: 3.44e+00	Critic Loss: 1.04e-01
Episode 439	Exploration: 0.250420	Average Score: -0.14	Current Score: -0.13	Actor Loss: 3.42e+00	Critic Loss: 1.80e-01
Episode 440	Exploration: 0.249420	Average Score: -0.14	Current Score: -0.28	Actor Loss: 3.66e+00	Critic Loss: 5.50e-02
Episode 441	Exploration: 0.248420	Average Score: -0.15	Current Score: -0.12	Actor Loss: 3.49e+00	Critic Loss: 2.37e-01
Episode 442	Exploration: 0.248120	Average Score: -0.15	Current Score: -0.11	Actor Loss: 3.66e+00	Critic Loss: 3.53e-02
Episode 443	Exploration: 0.247120	Average Score: -0.14	Current Score: -0.13	Actor Loss: 3.65e+00	Critic Loss: 1.18e-01
Episode 444	Exploration: 0.246120	Average Score: -0.14	Current Score: -0.15	Actor Loss: 3.55e+00	Critic Loss: 1.02e-01
Episode 445	Exploration: 0.245120	Average Score: -0.14	Current Score: -0.21	Actor Loss: 3.52e+00	Critic Loss: 6.57e-02
Episode 446	Exploration: 0.244860	Average Score: -0.14	Current Score: -0.01	Actor Loss: 3.31e+00	Critic Loss: 8.90e-02
Episode 447	Exploration: 0.243860	Average Score: -0.14	Current Score: -0.15	Actor Loss: 3.64e+00	Critic Loss: 4.26e-02
Episode 448	Exploration: 0.242860	Average Score: -0.14	Current Score: -0.18	Actor Loss: 3.63e+00	Critic Loss: 9.34e-02
Episode 449	Exploration: 0.241860	Average Score: -0.14	Current Score: -0.10	Actor Loss: 3.67e+00	Critic Loss: 5.27e-02
Episode 450	Exploration: 0.240860	Average Score: -0.14	Current Score: -0.08	Actor Loss: 3.78e+00	Critic Loss: 5.93e-02
Save Model
Episode 450	Average Score: -0.14
Episode 451	Exploration: 0.239860	Average Score: -0.14	Current Score: -0.12	Actor Loss: 3.68e+00	Critic Loss: 5.07e-02
Episode 452	Exploration: 0.238860	Average Score: -0.14	Current Score: -0.12	Actor Loss: 3.74e+00	Critic Loss: 1.06e-01
Episode 453	Exploration: 0.237860	Average Score: -0.14	Current Score: -0.16	Actor Loss: 3.53e+00	Critic Loss: 4.13e-02
Episode 454	Exploration: 0.236860	Average Score: -0.14	Current Score: -0.17	Actor Loss: 3.42e+00	Critic Loss: 3.54e-02
Episode 455	Exploration: 0.235860	Average Score: -0.14	Current Score: -0.19	Actor Loss: 3.64e+00	Critic Loss: 1.28e-01
Episode 456	Exploration: 0.234860	Average Score: -0.14	Current Score: -0.17	Actor Loss: 3.52e+00	Critic Loss: 5.11e-02
Episode 457	Exploration: 0.233860	Average Score: -0.14	Current Score: -0.30	Actor Loss: 3.49e+00	Critic Loss: 3.89e-02
Episode 458	Exploration: 0.232860	Average Score: -0.14	Current Score: -0.16	Actor Loss: 3.51e+00	Critic Loss: 3.85e-02
Episode 459	Exploration: 0.232400	Average Score: -0.14	Current Score: -0.09	Actor Loss: 3.63e+00	Critic Loss: 4.02e-02
Episode 460	Exploration: 0.231400	Average Score: -0.14	Current Score: -0.13	Actor Loss: 3.68e+00	Critic Loss: 8.31e-02
Episode 461	Exploration: 0.231320	Average Score: -0.13	Current Score: 0.39	Actor Loss: 3.50e+00	Critic Loss: 1.00e-01
Episode 462	Exploration: 0.230320	Average Score: -0.13	Current Score: -0.11	Actor Loss: 3.58e+00	Critic Loss: 4.29e-02
Episode 463	Exploration: 0.229320	Average Score: -0.13	Current Score: -0.27	Actor Loss: 3.46e+00	Critic Loss: 3.47e-02
Episode 464	Exploration: 0.228320	Average Score: -0.13	Current Score: -0.31	Actor Loss: 3.51e+00	Critic Loss: 1.76e-01
Episode 465	Exploration: 0.227320	Average Score: -0.13	Current Score: -0.19	Actor Loss: 3.57e+00	Critic Loss: 4.33e-02
Episode 466	Exploration: 0.226320	Average Score: -0.13	Current Score: -0.26	Actor Loss: 3.49e+00	Critic Loss: 3.95e-02
Episode 467	Exploration: 0.225320	Average Score: -0.14	Current Score: -0.19	Actor Loss: 3.83e+00	Critic Loss: 1.42e-01
Episode 468	Exploration: 0.224320	Average Score: -0.14	Current Score: -0.41	Actor Loss: 3.91e+00	Critic Loss: 6.61e-02
Episode 469	Exploration: 0.223320	Average Score: -0.14	Current Score: -0.19	Actor Loss: 3.90e+00	Critic Loss: 3.61e-02
Episode 470	Exploration: 0.222320	Average Score: -0.14	Current Score: -0.15	Actor Loss: 3.58e+00	Critic Loss: 3.72e-02
Episode 471	Exploration: 0.221320	Average Score: -0.14	Current Score: -0.20	Actor Loss: 3.66e+00	Critic Loss: 4.79e-02
Episode 472	Exploration: 0.220320	Average Score: -0.14	Current Score: -0.26	Actor Loss: 3.65e+00	Critic Loss: 4.93e-02
Episode 473	Exploration: 0.219320	Average Score: -0.14	Current Score: -0.21	Actor Loss: 3.71e+00	Critic Loss: 4.50e-02
Episode 474	Exploration: 0.218320	Average Score: -0.14	Current Score: -0.27	Actor Loss: 3.42e+00	Critic Loss: 4.58e-02
Episode 475	Exploration: 0.217320	Average Score: -0.14	Current Score: -0.19	Actor Loss: 3.63e+00	Critic Loss: 9.03e-02
Episode 476	Exploration: 0.216320	Average Score: -0.14	Current Score: -0.19	Actor Loss: 3.75e+00	Critic Loss: 2.15e-01
Episode 477	Exploration: 0.215320	Average Score: -0.14	Current Score: -0.16	Actor Loss: 3.59e+00	Critic Loss: 8.99e-02
Episode 478	Exploration: 0.214320	Average Score: -0.15	Current Score: -0.35	Actor Loss: 3.92e+00	Critic Loss: 3.52e-02
Episode 479	Exploration: 0.213320	Average Score: -0.15	Current Score: -0.17	Actor Loss: 3.45e+00	Critic Loss: 3.78e-02
Episode 480	Exploration: 0.212320	Average Score: -0.15	Current Score: -0.12	Actor Loss: 3.62e+00	Critic Loss: 4.29e-02
Episode 481	Exploration: 0.211320	Average Score: -0.15	Current Score: -0.22	Actor Loss: 3.69e+00	Critic Loss: 5.22e-02
Episode 482	Exploration: 0.210320	Average Score: -0.15	Current Score: -0.14	Actor Loss: 3.62e+00	Critic Loss: 3.28e-02
Episode 483	Exploration: 0.209320	Average Score: -0.15	Current Score: -0.12	Actor Loss: 3.66e+00	Critic Loss: 5.31e-02
Episode 484	Exploration: 0.208320	Average Score: -0.15	Current Score: -0.11	Actor Loss: 3.51e+00	Critic Loss: 7.32e-02
Episode 485	Exploration: 0.207320	Average Score: -0.15	Current Score: -0.17	Actor Loss: 3.41e+00	Critic Loss: 3.49e-02
Episode 486	Exploration: 0.206320	Average Score: -0.15	Current Score: -0.18	Actor Loss: 3.64e+00	Critic Loss: 2.80e-02
Episode 487	Exploration: 0.205780	Average Score: -0.15	Current Score: -0.10	Actor Loss: 3.75e+00	Critic Loss: 6.45e-02
Episode 488	Exploration: 0.204780	Average Score: -0.15	Current Score: -0.15	Actor Loss: 3.62e+00	Critic Loss: 5.60e-02
Episode 489	Exploration: 0.203780	Average Score: -0.15	Current Score: -0.14	Actor Loss: 3.46e+00	Critic Loss: 5.28e-02
Episode 490	Exploration: 0.203480	Average Score: -0.15	Current Score: -0.01	Actor Loss: 3.88e+00	Critic Loss: 3.20e-02
Episode 491	Exploration: 0.202760	Average Score: -0.15	Current Score: -0.05	Actor Loss: 3.75e+00	Critic Loss: 4.65e-02
Episode 492	Exploration: 0.202260	Average Score: -0.15	Current Score: -0.10	Actor Loss: 3.60e+00	Critic Loss: 5.11e-02
Episode 493	Exploration: 0.201760	Average Score: -0.15	Current Score: -0.09	Actor Loss: 3.85e+00	Critic Loss: 9.50e-02
Episode 494	Exploration: 0.201080	Average Score: -0.15	Current Score: -0.11	Actor Loss: 3.64e+00	Critic Loss: 1.15e-01
Episode 495	Exploration: 0.200080	Average Score: -0.15	Current Score: -0.19	Actor Loss: 3.65e+00	Critic Loss: 1.76e-01
Episode 496	Exploration: 0.199080	Average Score: -0.15	Current Score: -0.20	Actor Loss: 3.70e+00	Critic Loss: 3.69e-02
Episode 497	Exploration: 0.198080	Average Score: -0.15	Current Score: -0.38	Actor Loss: 3.68e+00	Critic Loss: 1.72e-01
Episode 498	Exploration: 0.197080	Average Score: -0.15	Current Score: -0.17	Actor Loss: 3.60e+00	Critic Loss: 5.31e-02
Episode 499	Exploration: 0.196080	Average Score: -0.15	Current Score: -0.17	Actor Loss: 3.42e+00	Critic Loss: 1.42e-01
Episode 500	Exploration: 0.195080	Average Score: -0.15	Current Score: -0.21	Actor Loss: 3.58e+00	Critic Loss: 4.02e-02
Episode 500	Average Score: -0.15
Save Model
Episode 500	Average Score: -0.15
Episode 501	Exploration: 0.194080	Average Score: -0.15	Current Score: -0.14	Actor Loss: 3.52e+00	Critic Loss: 1.83e-01
Episode 502	Exploration: 0.193080	Average Score: -0.15	Current Score: -0.18	Actor Loss: 3.63e+00	Critic Loss: 6.96e-02
Episode 503	Exploration: 0.192600	Average Score: -0.15	Current Score: -0.11	Actor Loss: 3.62e+00	Critic Loss: 9.26e-02
Episode 504	Exploration: 0.191600	Average Score: -0.15	Current Score: -0.16	Actor Loss: 3.64e+00	Critic Loss: 4.67e-02
Episode 505	Exploration: 0.190600	Average Score: -0.15	Current Score: -0.11	Actor Loss: 3.57e+00	Critic Loss: 1.47e-01
Episode 506	Exploration: 0.189600	Average Score: -0.15	Current Score: -0.28	Actor Loss: 3.63e+00	Critic Loss: 6.70e-02
Episode 507	Exploration: 0.188600	Average Score: -0.15	Current Score: -0.15	Actor Loss: 3.62e+00	Critic Loss: 1.72e-01
Episode 508	Exploration: 0.187600	Average Score: -0.16	Current Score: -0.10	Actor Loss: 3.87e+00	Critic Loss: 1.68e-01
Episode 509	Exploration: 0.186600	Average Score: -0.16	Current Score: -0.13	Actor Loss: 3.82e+00	Critic Loss: 6.47e-02
Episode 510	Exploration: 0.186140	Average Score: -0.16	Current Score: -0.03	Actor Loss: 3.71e+00	Critic Loss: 6.24e-02
Episode 511	Exploration: 0.185140	Average Score: -0.16	Current Score: -0.22	Actor Loss: 3.77e+00	Critic Loss: 2.75e-01
Episode 512	Exploration: 0.184140	Average Score: -0.16	Current Score: -0.25	Actor Loss: 3.65e+00	Critic Loss: 7.38e-02
Episode 513	Exploration: 0.183920	Average Score: -0.16	Current Score: 0.01	Actor Loss: 3.52e+00	Critic Loss: 6.87e-02
Episode 514	Exploration: 0.182920	Average Score: -0.16	Current Score: -0.17	Actor Loss: 3.67e+00	Critic Loss: 4.31e-02
Episode 515	Exploration: 0.181920	Average Score: -0.16	Current Score: -0.12	Actor Loss: 3.59e+00	Critic Loss: 1.65e-01
Episode 516	Exploration: 0.181660	Average Score: -0.16	Current Score: -0.03	Actor Loss: 3.62e+00	Critic Loss: 2.99e-02
Episode 517	Exploration: 0.181000	Average Score: -0.16	Current Score: -0.14	Actor Loss: 3.39e+00	Critic Loss: 6.59e-02
Episode 518	Exploration: 0.180000	Average Score: -0.16	Current Score: -0.21	Actor Loss: 3.68e+00	Critic Loss: 4.01e-02
Episode 519	Exploration: 0.179000	Average Score: -0.16	Current Score: -0.19	Actor Loss: 3.61e+00	Critic Loss: 4.46e-02
Episode 520	Exploration: 0.178000	Average Score: -0.16	Current Score: -0.20	Actor Loss: 3.74e+00	Critic Loss: 6.40e-02
Episode 521	Exploration: 0.177000	Average Score: -0.16	Current Score: -0.20	Actor Loss: 3.61e+00	Critic Loss: 8.53e-02
Episode 522	Exploration: 0.176000	Average Score: -0.16	Current Score: -0.12	Actor Loss: 3.45e+00	Critic Loss: 2.06e-01
Episode 523	Exploration: 0.175000	Average Score: -0.16	Current Score: -0.20	Actor Loss: 3.76e+00	Critic Loss: 6.76e-02
Episode 524	Exploration: 0.174340	Average Score: -0.16	Current Score: -0.12	Actor Loss: 3.81e+00	Critic Loss: 7.45e-02
Episode 525	Exploration: 0.173660	Average Score: -0.16	Current Score: -0.08	Actor Loss: 3.65e+00	Critic Loss: 8.13e-02
Episode 526	Exploration: 0.172660	Average Score: -0.16	Current Score: -0.16	Actor Loss: 3.46e+00	Critic Loss: 7.01e-02
Episode 527	Exploration: 0.171660	Average Score: -0.15	Current Score: -0.14	Actor Loss: 3.72e+00	Critic Loss: 2.97e-02
Episode 528	Exploration: 0.170660	Average Score: -0.15	Current Score: -0.17	Actor Loss: 3.65e+00	Critic Loss: 3.89e-02
Episode 529	Exploration: 0.169660	Average Score: -0.15	Current Score: -0.15	Actor Loss: 3.63e+00	Critic Loss: 7.61e-02
Episode 530	Exploration: 0.168660	Average Score: -0.16	Current Score: -0.16	Actor Loss: 3.53e+00	Critic Loss: 5.57e-02
Episode 531	Exploration: 0.167660	Average Score: -0.16	Current Score: -0.21	Actor Loss: 3.70e+00	Critic Loss: 7.92e-02
Episode 532	Exploration: 0.166660	Average Score: -0.16	Current Score: -0.19	Actor Loss: 3.78e+00	Critic Loss: 1.85e-01
Episode 533	Exploration: 0.165660	Average Score: -0.16	Current Score: -0.16	Actor Loss: 3.39e+00	Critic Loss: 8.83e-02
Episode 534	Exploration: 0.165340	Average Score: -0.16	Current Score: -0.03	Actor Loss: 3.74e+00	Critic Loss: 1.36e-01
Episode 535	Exploration: 0.164860	Average Score: -0.16	Current Score: -0.11	Actor Loss: 3.64e+00	Critic Loss: 1.51e-01
Episode 536	Exploration: 0.163860	Average Score: -0.16	Current Score: -0.19	Actor Loss: 3.59e+00	Critic Loss: 7.39e-02
Episode 537	Exploration: 0.163840	Average Score: -0.14	Current Score: 1.90	Actor Loss: 3.46e+00	Critic Loss: 1.05e-01
Episode 538	Exploration: 0.162840	Average Score: -0.14	Current Score: -0.12	Actor Loss: 3.82e+00	Critic Loss: 7.11e-02
Episode 539	Exploration: 0.161840	Average Score: -0.14	Current Score: -0.16	Actor Loss: 3.66e+00	Critic Loss: 5.42e-02
Episode 540	Exploration: 0.161600	Average Score: -0.13	Current Score: 0.03	Actor Loss: 3.76e+00	Critic Loss: 4.83e-02
Episode 541	Exploration: 0.160600	Average Score: -0.13	Current Score: -0.17	Actor Loss: 3.64e+00	Critic Loss: 5.55e-02
Episode 542	Exploration: 0.159600	Average Score: -0.13	Current Score: -0.20	Actor Loss: 3.56e+00	Critic Loss: 1.08e-01
Episode 543	Exploration: 0.158600	Average Score: -0.13	Current Score: -0.16	Actor Loss: 3.75e+00	Critic Loss: 8.48e-02
Episode 544	Exploration: 0.157600	Average Score: -0.14	Current Score: -0.17	Actor Loss: 3.73e+00	Critic Loss: 3.66e-02
qt.qpa.xkeyboard: failed to compile a keymap
Episode 545	Exploration: 0.156600	Average Score: -0.13	Current Score: -0.18	Actor Loss: 3.68e+00	Critic Loss: 1.11e-01
Episode 546	Exploration: 0.155600	Average Score: -0.14	Current Score: -0.23	Actor Loss: 3.55e+00	Critic Loss: 8.39e-02
Episode 547	Exploration: 0.154600	Average Score: -0.14	Current Score: -0.20	Actor Loss: 3.78e+00	Critic Loss: 1.25e-01
